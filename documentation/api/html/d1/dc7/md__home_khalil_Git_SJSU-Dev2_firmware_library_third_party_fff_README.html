<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.13"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>SJSU-Dev2: # Fake Function Framework  (fff)</title>
        <!--<link href="../../tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="../../dynsections.js"></script>
        <link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
        <link href="../../doxygen.css" rel="stylesheet" type="text/css" />
        <link href="../../customdoxygen.css" rel="stylesheet" type="text/css"/>
<link href="../../jquery.smartmenus.bootstrap.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
        <link href="../../jquery.smartmenus.bootstrap.css" rel="stylesheet">
        <script type="text/javascript" src="../../jquery.smartmenus.min.js"></script>
        <!-- SmartMenus jQuery Bootstrap Addon -->
        <script type="text/javascript" src="../../jquery.smartmenus.bootstrap.min.js"></script>
        <!-- SmartMenus jQuery plugin -->
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">SJSU-Dev2 </a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title"># Fake Function Framework (fff) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://travis-ci.org/meekrosoft/fff"></a></p>
<h2>A Fake Function Framework for C</h2>
<p>fff is a micro-framework for creating fake C functions for tests. Because life is too short to spend time hand-writing fake functions for testing.</p>
<h2>Hello fake world!</h2>
<p>Say you are testing an embedded user interface and you have a function that you want to create a fake for:</p>
<div class="fragment"><div class="line"><span class="comment">// UI.c</span></div><div class="line">...</div><div class="line">void DISPLAY_init();</div><div class="line">...</div></div><!-- fragment --><p>Here's how you would define a fake function for this in your test suite:</p>
<div class="fragment"><div class="line"><span class="comment">// test.c(pp)</span></div><div class="line"><span class="preprocessor">#include &quot;fff.h&quot;</span></div><div class="line">DEFINE_FFF_GLOBALS;</div><div class="line">FAKE_VOID_FUNC(DISPLAY_init);</div></div><!-- fragment --><p>And the unit test might look something like this:</p>
<div class="fragment"><div class="line">TEST_F(GreeterTests, init_initialises_display)</div><div class="line">{</div><div class="line">    UI_init();</div><div class="line">    ASSERT_EQ(DISPLAY_init_fake.call_count, 1);</div><div class="line">}</div></div><!-- fragment --><p>So what has happened here? The first thing to note is that the framework is header only, all you need to do to use it is download <code><a class="el" href="../../d1/dce/fff_8h_source.html">fff.h</a></code> and include it in your test suite.</p>
<p>The magic is in the <code>FAKE_VOID_FUNC</code>. This expands a macro that defines a function returning <code>void</code> which has zero arguments. It also defines a struct <code>"function_name"_fake</code> which contains all the information about the fake. For instance, <code>DISPLAY_init_fake.call_count</code>is incremented every time the faked function is called.</p>
<p>Under the hood it generates a struct that looks like this:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>DISPLAY_init_Fake {</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> call_count;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> arg_history_len;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> arg_histories_dropped;</div><div class="line">    void(*custom_fake)();</div><div class="line">} DISPLAY_init_Fake;</div><div class="line">DISPLAY_init_Fake DISPLAY_init_fake;</div></div><!-- fragment --><h2>Capturing arguments</h2>
<p>Ok, enough with the toy examples. What about faking functions with arguments?</p>
<div class="fragment"><div class="line"><span class="comment">// UI.c</span></div><div class="line">...</div><div class="line">void DISPLAY_output(<span class="keywordtype">char</span> * message);</div><div class="line">...</div></div><!-- fragment --><p>Here's how you would define a fake function for this in your test suite:</p>
<div class="fragment"><div class="line">FAKE_VOID_FUNC(DISPLAY_output, <span class="keywordtype">char</span> *);</div></div><!-- fragment --><p>And the unit test might look something like this:</p>
<div class="fragment"><div class="line">TEST_F(UITests, write_line_outputs_lines_to_display)</div><div class="line">{</div><div class="line">    <span class="keywordtype">char</span> msg[] = <span class="stringliteral">&quot;helloworld&quot;</span>;</div><div class="line">    UI_write_line(msg);</div><div class="line">    ASSERT_EQ(DISPLAY_output_fake.call_count, 1);</div><div class="line">    ASSERT_EQ(strncmp(DISPLAY_output_fake.arg0_val, msg, 26), 0);</div><div class="line">}</div></div><!-- fragment --><p>There is no more magic here, the <code>FAKE_VOID_FUNC</code> works as in the previous example. The number of arguments that the function takes is calculated, and the macro arguments following the function name defines the argument type (a char pointer in this example).</p>
<p>A variable is created for every argument in the form <code>"function_name"fake.argN_val</code></p>
<h2>Return values</h2>
<p>When you want to define a fake function that returns a value, you should use the <code>FAKE_VALUE_FUNC</code> macro. For instance:</p>
<div class="fragment"><div class="line"><span class="comment">// UI.c</span></div><div class="line">...</div><div class="line">unsigned <span class="keywordtype">int</span> DISPLAY_get_line_capacity();</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> DISPLAY_get_line_insert_index();</div><div class="line">...</div></div><!-- fragment --><p>Here's how you would define fake functions for these in your test suite:</p>
<div class="fragment"><div class="line">FAKE_VALUE_FUNC(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, DISPLAY_get_line_capacity);</div><div class="line">FAKE_VALUE_FUNC(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, DISPLAY_get_line_insert_index);</div></div><!-- fragment --><p>And the unit test might look something like this:</p>
<div class="fragment"><div class="line">TEST_F(UITests, when_empty_lines_write_line_doesnt_clear_screen)</div><div class="line">{</div><div class="line">    <span class="comment">// given</span></div><div class="line">    DISPLAY_get_line_insert_index_fake.return_val = 1;</div><div class="line">    <span class="keywordtype">char</span> msg[] = <span class="stringliteral">&quot;helloworld&quot;</span>;</div><div class="line">    <span class="comment">// when</span></div><div class="line">    UI_write_line(msg);</div><div class="line">    <span class="comment">// then</span></div><div class="line">    ASSERT_EQ(DISPLAY_clear_fake.call_count, 0);</div><div class="line">}</div></div><!-- fragment --><p>Of course you can mix and match these macros to define a value function with arguments, for instance to fake:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> pow(<span class="keywordtype">double</span> base, <span class="keywordtype">double</span> exponent);</div></div><!-- fragment --><p>you would use a syntax like this:</p>
<div class="fragment"><div class="line">FAKE_VALUE_FUNC(<span class="keywordtype">double</span>, pow, <span class="keywordtype">double</span>, <span class="keywordtype">double</span>);</div></div><!-- fragment --><h2>Resetting a fake</h2>
<p>Good tests are isolated tests, so it is important to reset the fakes for each unit test. All the fakes have a reset function to reset their arguments and call counts. It is good practice is to call the reset function for all the fakes in the setup function of your test suite.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> setup()</div><div class="line">{</div><div class="line">    <span class="comment">// Register resets</span></div><div class="line">    RESET_FAKE(DISPLAY_init);</div><div class="line">    RESET_FAKE(DISPLAY_clear);</div><div class="line">    RESET_FAKE(DISPLAY_output_message);</div><div class="line">    RESET_FAKE(DISPLAY_get_line_capacity);</div><div class="line">    RESET_FAKE(DISPLAY_get_line_insert_index);</div><div class="line">}</div></div><!-- fragment --><p>You might want to define a macro to do this:</p>
<div class="fragment"><div class="line"><span class="comment">/* List of fakes used by this unit tester */</span></div><div class="line"><span class="preprocessor">#define FFF_FAKES_LIST(FAKE)            \</span></div><div class="line"><span class="preprocessor">  FAKE(DISPLAY_init)                    \</span></div><div class="line"><span class="preprocessor">  FAKE(DISPLAY_clear)                   \</span></div><div class="line"><span class="preprocessor">  FAKE(DISPLAY_output_message)          \</span></div><div class="line"><span class="preprocessor">  FAKE(DISPLAY_get_line_capacity)       \</span></div><div class="line"><span class="preprocessor">  FAKE(DISPLAY_get_line_insert_index)</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> setup()</div><div class="line">{</div><div class="line">  <span class="comment">/* Register resets */</span></div><div class="line">  FFF_FAKES_LIST(RESET_FAKE);</div><div class="line"></div><div class="line">  <span class="comment">/* reset common FFF internal structures */</span></div><div class="line">  FFF_RESET_HISTORY();</div><div class="line">}</div></div><!-- fragment --><h2>Call history</h2>
<p>Say you want to test that a function calls functionA, then functionB, then functionA again, how would you do that? Well <code>fff</code> maintains a call history so that it is easy to assert these expectations.</p>
<p>Here's how it works:</p>
<div class="fragment"><div class="line">FAKE_VOID_FUNC(voidfunc2, <span class="keywordtype">char</span>, <span class="keywordtype">char</span>);</div><div class="line">FAKE_VALUE_FUNC(<span class="keywordtype">long</span>, longfunc0);</div><div class="line"></div><div class="line">TEST_F(FFFTestSuite, calls_in_correct_order)</div><div class="line">{</div><div class="line">    longfunc0();</div><div class="line">    voidfunc2();</div><div class="line">    longfunc0();</div><div class="line"></div><div class="line">    ASSERT_EQ(fff.call_history[0], (<span class="keywordtype">void</span> *)longfunc0);</div><div class="line">    ASSERT_EQ(fff.call_history[1], (<span class="keywordtype">void</span> *)voidfunc2);</div><div class="line">    ASSERT_EQ(fff.call_history[2], (<span class="keywordtype">void</span> *)longfunc0);</div><div class="line">}</div></div><!-- fragment --><p>They are reset by calling <code>FFF_RESET_HISTORY();</code></p>
<h2>Default Argument History</h2>
<p>The framework will by default store the arguments for the last ten calls made to a fake function.</p>
<div class="fragment"><div class="line">TEST_F(FFFTestSuite, when_fake_func_called_then_arguments_captured_in_history)</div><div class="line">{</div><div class="line">    voidfunc2(<span class="charliteral">&#39;g&#39;</span>, <span class="charliteral">&#39;h&#39;</span>);</div><div class="line">    voidfunc2(<span class="charliteral">&#39;i&#39;</span>, <span class="charliteral">&#39;j&#39;</span>);</div><div class="line">    ASSERT_EQ(<span class="charliteral">&#39;g&#39;</span>, voidfunc2_fake.arg0_history[0]);</div><div class="line">    ASSERT_EQ(<span class="charliteral">&#39;h&#39;</span>, voidfunc2_fake.arg1_history[0]);</div><div class="line">    ASSERT_EQ(<span class="charliteral">&#39;i&#39;</span>, voidfunc2_fake.arg0_history[1]);</div><div class="line">    ASSERT_EQ(<span class="charliteral">&#39;j&#39;</span>, voidfunc2_fake.arg1_history[1]);</div><div class="line">}</div></div><!-- fragment --><p>There are two ways to find out if calls have been dropped. The first is to check the dropped histories counter:</p>
<div class="fragment"><div class="line">TEST_F(FFFTestSuite, when_fake_func_called_max_times_plus_one_then_one_argument_history_dropped)</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> i;</div><div class="line">    <span class="keywordflow">for</span>(i = 0; i &lt; 10; i++)</div><div class="line">    {</div><div class="line">        voidfunc2(<span class="charliteral">&#39;1&#39;</span>+i, <span class="charliteral">&#39;2&#39;</span>+i);</div><div class="line">    }</div><div class="line">    voidfunc2(<span class="charliteral">&#39;1&#39;</span>, <span class="charliteral">&#39;2&#39;</span>);</div><div class="line">    ASSERT_EQ(1u, voidfunc2_fake.arg_histories_dropped);</div><div class="line">}</div></div><!-- fragment --><p>The other is to check if the call count is greater than the history size:</p>
<div class="fragment"><div class="line">ASSERT(voidfunc2_fake.arg_history_len &lt; voidfunc2_fake.call_count);</div></div><!-- fragment --><p>The argument histories for a fake function are reset when the RESET_FAKE function is called</p>
<h2>User Defined Argument History</h2>
<p>If you wish to control how many calls to capture for argument history you can override the default by defining it before include the <code><a class="el" href="../../d1/dce/fff_8h_source.html">fff.h</a></code> like this:</p>
<div class="fragment"><div class="line"><span class="comment">// Want to keep the argument history for 13 calls</span></div><div class="line"><span class="preprocessor">#define FFF_ARG_HISTORY_LEN 13</span></div><div class="line"><span class="comment">// Want to keep the call sequence history for 17 function calls</span></div><div class="line"><span class="preprocessor">#define FFF_CALL_HISTORY_LEN 17</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;../fff.h&quot;</span></div></div><!-- fragment --><h2>Function Return Value Sequences</h2>
<p>Often in testing we would like to test the behaviour of sequence of function call events. One way to do this with fff is to specify a sequence of return values with for the fake function. It is probably easier to describe with an example:</p>
<div class="fragment"><div class="line"><span class="comment">// faking &quot;long longfunc();&quot;</span></div><div class="line">FAKE_VALUE_FUNC(<span class="keywordtype">long</span>, longfunc0);</div><div class="line"></div><div class="line">TEST_F(FFFTestSuite, return_value_sequences_exhausted)</div><div class="line">{</div><div class="line">    <span class="keywordtype">long</span> myReturnVals[3] = { 3, 7, 9 };</div><div class="line">    SET_RETURN_SEQ(longfunc0, myReturnVals, 3);</div><div class="line">    ASSERT_EQ(myReturnVals[0], longfunc0());</div><div class="line">    ASSERT_EQ(myReturnVals[1], longfunc0());</div><div class="line">    ASSERT_EQ(myReturnVals[2], longfunc0());</div><div class="line">    ASSERT_EQ(myReturnVals[2], longfunc0());</div><div class="line">    ASSERT_EQ(myReturnVals[2], longfunc0());</div><div class="line">}</div></div><!-- fragment --><p>By specifying a return value sequence using the <code>SET_RETURN_SEQ</code> macro, the fake will return the values given in the parameter array in sequence. When the end of the sequence is reached the fake will continue to return the last value in the sequence indefinitely.</p>
<h2>Custom Return Value Delegate</h2>
<p>You can specify your own function to provide the return value for the fake. This is done by setting the custom_fake member of the fake. Here's an example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define MEANING_OF_LIFE 42</span></div><div class="line"><span class="keywordtype">long</span> my_custom_value_fake(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> MEANING_OF_LIFE;</div><div class="line">}</div><div class="line">TEST_F(FFFTestSuite, when_value_custom_fake_called_THEN_it_returns_custom_return_value)</div><div class="line">{</div><div class="line">    longfunc0_fake.custom_fake = my_custom_value_fake;</div><div class="line">    <span class="keywordtype">long</span> retval = longfunc0();</div><div class="line">    ASSERT_EQ(MEANING_OF_LIFE, retval);</div><div class="line">}</div></div><!-- fragment --><h2>Custom Return Value Delegate Sequences</h2>
<p>Say you have a function with an out parameter, and you want it to have a different behaviour on the first three calls, for example: set the value 'x' to the out parameter on the first call, the value 'y' to the out parameter on the second call, and the value 'z' to the out parameter on the third call. You can specify a sequence of custom functions to a non-variadic function using the SET_CUSTOM_FAKE_SEQ macro. Here's an example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> voidfunc1outparam_custom_fake1(<span class="keywordtype">char</span> *a)</div><div class="line">{</div><div class="line">    *a = <span class="charliteral">&#39;x&#39;</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> voidfunc1outparam_custom_fake2(<span class="keywordtype">char</span> *a)</div><div class="line">{</div><div class="line">    *a = <span class="charliteral">&#39;y&#39;</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> voidfunc1outparam_custom_fake3(<span class="keywordtype">char</span> *a)</div><div class="line">{</div><div class="line">    *a = <span class="charliteral">&#39;z&#39;</span>;</div><div class="line">}</div><div class="line"></div><div class="line">TEST_F(FFFTestSuite, custom_fake_sequence_not_exausthed)</div><div class="line">{</div><div class="line">    void (*custom_fakes[])(<span class="keywordtype">char</span> *) = {voidfunc1outparam_custom_fake1,</div><div class="line">                                      voidfunc1outparam_custom_fake2,</div><div class="line">                                      voidfunc1outparam_custom_fake3};</div><div class="line">    <span class="keywordtype">char</span> a = <span class="charliteral">&#39;a&#39;</span>;</div><div class="line"></div><div class="line">    SET_CUSTOM_FAKE_SEQ(voidfunc1outparam, custom_fakes, 3);</div><div class="line"></div><div class="line">    voidfunc1outparam(&amp;a);</div><div class="line">    ASSERT_EQ(<span class="charliteral">&#39;x&#39;</span>, a);</div><div class="line">    voidfunc1outparam(&amp;a);</div><div class="line">    ASSERT_EQ(<span class="charliteral">&#39;y&#39;</span>, a);</div><div class="line">    voidfunc1outparam(&amp;a);</div><div class="line">    ASSERT_EQ(<span class="charliteral">&#39;z&#39;</span>, a);</div><div class="line">}</div></div><!-- fragment --><p>The fake will call your custom functions in the order specified by the SET_CUSTOM_FAKE_SEQ macro. When the last custom fake is reached the fake will keep calling the last custom fake in the sequence. This macro works much like the SET_RETURN_SEQ macro.</p>
<h2>Return value history</h2>
<p>Say you have two functions f1 and f2. f2 must be called to release some resource allocated by f1, but only in the cases where f1 returns zero. f1 could be pthread_mutex_trylock and f2 could be pthread_mutex_unlock. <code>fff</code> will save the history of returned values so this can be easily checked, even when you use a sequence of custom fakes. Here's a simple example: </p><pre class="fragment">TEST_F(FFFTestSuite, return_value_sequence_saved_in_history)
{
    long myReturnVals[3] = { 3, 7, 9 };
    SET_RETURN_SEQ(longfunc0, myReturnVals, 3);
    longfunc0();
    longfunc0();
    longfunc0();
    ASSERT_EQ(myReturnVals[0], longfunc0_fake.return_val_history[0]);
    ASSERT_EQ(myReturnVals[1], longfunc0_fake.return_val_history[1]);
    ASSERT_EQ(myReturnVals[2], longfunc0_fake.return_val_history[2]);
}
</pre><p>You access the returned values in the <code>return_val_history</code> field.</p>
<h2>Variadic Functions</h2>
<p>You can fake variadic functions using the macros <code>FAKE_VALUE_FUNC_VARARG</code> and <code>FAKE_VOID_FUNC_VARARG</code>. For instance: </p><pre class="fragment">FAKE_VALUE_FUNC_VARARG(int, fprintf, FILE *, const char*, ...);
</pre><p>In order to access the variadic parameters from a custom fake function, declare a <code>va_list</code> parameter. For instance, a custom fake for <code>fprintf()</code> could call the real <code>fprintf()</code> like this: </p><pre class="fragment">int fprintf_custom(FILE *stream, const char *format, va_list ap) {
  if (fprintf0_fake.return_val &lt; 0) // should we fail?
    return fprintf0_fake.return_val;
  return vfprintf(stream, format, ap);
}
</pre><h2>How do I fake a function that returns a value by reference?</h2>
<p>The basic mechanism that FFF provides you in this case is the custom_fake field described in the <em>Custom Return Value Delegate</em> example above.</p>
<p>You need to create a custom function (e.g. getTime_custom_fake) to produce the output optionally by use of a helper variable (e.g. getTime_custom_now) to retrieve that output from. Then some creativity to tie it all together. The most important part (IMHO) is to keep your test case readable and maintainable.</p>
<p>In case your project uses a C compiler that supports nested functions (e.g. GCC) you can even combine all this in a single unit test function so you can easily oversee all details of the test.</p>
<div class="fragment"><div class="line"><span class="comment">/* The time structure */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div><div class="line">   <span class="keywordtype">int</span> hour, min;</div><div class="line">} Time;</div><div class="line"></div><div class="line"><span class="comment">/* Our fake function */</span></div><div class="line">FAKE_VOID_FUNC(getTime, Time*);</div><div class="line"></div><div class="line"><span class="comment">/* A test using the getTime fake function */</span></div><div class="line">TEST_F(FFFTestSuite, when_value_custom_fake_called_THEN_it_returns_custom_output)</div><div class="line">{</div><div class="line">    Time t;</div><div class="line">    Time getTime_custom_now;</div><div class="line">    <span class="keywordtype">void</span> getTime_custom_fake(Time *now) {</div><div class="line">        *now = getTime_custom_now;</div><div class="line">    }</div><div class="line">    getTime_fake.custom_fake = getTime_custom_fake;</div><div class="line"></div><div class="line">    <span class="comment">/* given a specific time */</span></div><div class="line">    getTime_custom_now.hour = 13;</div><div class="line">    getTime_custom_now.min  = 05;</div><div class="line"></div><div class="line">    <span class="comment">/* when getTime is called */</span></div><div class="line">    getTime(&amp;t);</div><div class="line"></div><div class="line">    <span class="comment">/* then the specific time must be produced */</span></div><div class="line">    ASSERT_EQ(t.hour, 13);</div><div class="line">    ASSERT_EQ(t.min,  05);</div><div class="line">}</div></div><!-- fragment --><h2>How do I fake a function with a function pointer parameter?</h2>
<p>Using FFF to stub functions that have function pointer parameter can cause problems when trying to stub them. Presented here is an example how to deal with this situation.</p>
<p>If you need to stub a function that has a function pointer parameter, e.g. something like:</p>
<div class="fragment"><div class="line"><span class="comment">/* timer.h */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">int</span> timer_handle;</div><div class="line"><span class="keyword">extern</span> <span class="keywordtype">int</span> timer_start(timer_handle handle, <span class="keywordtype">long</span> delay, <span class="keywordtype">void</span> (*cb_function) (<span class="keywordtype">int</span> arg), <span class="keywordtype">int</span> arg);</div></div><!-- fragment --><p>Then creating a fake like below will horribly fail when trying to compile because the FFF macro will internally expand into an illegal variable <code>int (*)(int) arg2_val</code>.</p>
<div class="fragment"><div class="line"><span class="comment">/* The fake, attempt one */</span></div><div class="line">FAKE_VALUE_FUNC(<span class="keywordtype">int</span>,</div><div class="line">                timer_start,</div><div class="line">                timer_handle,</div><div class="line">                <span class="keywordtype">long</span>,</div><div class="line">                <span class="keywordtype">void</span> (*) (<span class="keywordtype">int</span> argument),</div><div class="line">                <span class="keywordtype">int</span>);</div></div><!-- fragment --><p>The solution to this problem is to create a bridging type that needs only to be visible in the unit tester. The fake will use that intermediate type. This way the compiler will not complain because the types match.</p>
<div class="fragment"><div class="line"><span class="comment">/* Additional type needed to be able to use callback in FFF */</span></div><div class="line"><span class="keyword">typedef</span> void (*timer_cb) (<span class="keywordtype">int</span> argument);</div><div class="line"></div><div class="line"><span class="comment">/* The fake, attempt two */</span></div><div class="line">FAKE_VALUE_FUNC(<span class="keywordtype">int</span>,</div><div class="line">                timer_start,</div><div class="line">                timer_handle,</div><div class="line">                <span class="keywordtype">long</span>,</div><div class="line">                timer_cb,</div><div class="line">                <span class="keywordtype">int</span>);</div></div><!-- fragment --><p>Here are some ideas how to create a test case with callbacks.</p>
<div class="fragment"><div class="line"><span class="comment">/* Unit test */</span></div><div class="line">TEST_F(FFFTestSuite, test_fake_with_function_pointer)</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> cb_timeout_called = 0;</div><div class="line">    <span class="keywordtype">int</span> result = 0;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> cb_timeout(<span class="keywordtype">int</span> argument)</div><div class="line">    {</div><div class="line">      cb_timeout_called++;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> timer_start_custom_fake(timer_handle handle,</div><div class="line">                          <span class="keywordtype">long</span> delay,</div><div class="line">                          <span class="keywordtype">void</span> (*cb_function) (<span class="keywordtype">int</span> arg),</div><div class="line">                          <span class="keywordtype">int</span> arg)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (cb_function) cb_function(arg);</div><div class="line">      <span class="keywordflow">return</span> timer_start_fake.return_val;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* given the custom fake for timer_start */</span></div><div class="line">    timer_start_fake.return_val = 33;</div><div class="line">    timer_start_fake.custom_fake = timer_start_custom_fake;</div><div class="line"></div><div class="line">    <span class="comment">/* when timer_start is called</span></div><div class="line"><span class="comment">     * (actually you would call your own function-under-test</span></div><div class="line"><span class="comment">     *  that would then call the fake function)</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    result = timer_start(10, 100, cb_timeout, 55);</div><div class="line"></div><div class="line">    <span class="comment">/* then the timer_start fake must have been called correctly */</span></div><div class="line">    ASSERT_EQ(result, 33);</div><div class="line">    ASSERT_EQ(timer_start_fake.call_count, 1);</div><div class="line">    ASSERT_EQ(timer_start_fake.arg0_val,   10);</div><div class="line">    ASSERT_EQ(timer_start_fake.arg1_val,   100);</div><div class="line">    ASSERT_EQ(timer_start_fake.arg2_val,   cb_timeout); <span class="comment">/* callback provided by unit tester */</span></div><div class="line">    ASSERT_EQ(timer_start_fake.arg3_val,   55);</div><div class="line"></div><div class="line">    <span class="comment">/* and ofcourse our custom fake correctly calls the registered callback */</span></div><div class="line">    ASSERT_EQ(cb_timeout_called, 1);</div><div class="line">}</div></div><!-- fragment --> <h2>How do I reuse a fake across multiple test-suites?</h2>
<p>FFF functions like FAKE_VALUE_FUNC will perform both the declaration AND the definition of the fake function and the corresponding data structs. This cannot be placed in a header, since it will lead to multiple definitions of the fake functions.</p>
<p>The solution is to separate declaration and definition of the fakes, and place the declaration into a public header file, and the definition into a private source file.</p>
<p>Here is an example of how it could be done:</p>
<div class="fragment"><div class="line"><span class="comment">/* Public header file */</span></div><div class="line"><span class="preprocessor">#include &quot;fff.h&quot;</span></div><div class="line"></div><div class="line">DECLARE_FAKE_VALUE_FUNC(<span class="keywordtype">int</span>, value_function, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>);</div><div class="line">DECLARE_FAKE_VOID_FUNC(void_function, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>);</div><div class="line">DECLARE_FAKE_VALUE_FUNC_VARARG(<span class="keywordtype">int</span>, value_function_vargs, <span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keywordtype">int</span>, ...);</div><div class="line">DECLARE_FAKE_VOID_FUNC_VARARG(void_function_vargs, <span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keywordtype">int</span>, ...);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/* Private source file file */</span></div><div class="line"><span class="preprocessor">#include &quot;public_header.h&quot;</span></div><div class="line"></div><div class="line">DEFINE_FAKE_VALUE_FUNC(<span class="keywordtype">int</span>, value_function, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>);</div><div class="line">DEFINE_FAKE_VOID_FUNC(void_function, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>);</div><div class="line">DEFINE_FAKE_VALUE_FUNC_VARARG(<span class="keywordtype">int</span>, value_function_vargs, <span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keywordtype">int</span>, ...);</div><div class="line">DEFINE_FAKE_VOID_FUNC_VARARG(void_function_vargs, <span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keywordtype">int</span>, ...);</div></div><!-- fragment --><h2>Find out more...</h2>
<p>Look under the examples directory for full length examples in both C and C++. There is also a test suite for the framework under the test directory. </p><hr/>
<h2>Benefits</h2>
<p>So whats the point?</p>
<ul>
<li>To make it easy to create fake functions for testing C code.</li>
<li>It is simple - just include a header file and you are good to go.</li>
<li>To work in both C and C++ test environments</li>
</ul>
<h2>Under the hood:</h2>
<ul>
<li>The <a class="el" href="../../d1/dce/fff_8h_source.html">fff.h</a> header file is generated by a ruby script</li>
<li>There are tests under src/test</li>
<li>There is an example for testing an embedded UI and a hardware driver under src/examples</li>
</ul>
<h2>Cheat Sheet</h2>
<table class="doxtable">
<tr>
<th>Macro </th><th>Description </th><th><a class="el" href="../../d2/d31/classExample.html">Example</a>  </th></tr>
<tr>
<td>FAKE_VOID_FUNC(fn [,arg_types*]); </td><td>Define a fake function named fn returning void with n arguments </td><td>FAKE_VOID_FUNC(DISPLAY_output_message, const char*); </td></tr>
<tr>
<td>FAKE_VALUE_FUNC(return_type, fn [,arg_types*]); </td><td>Define a fake function returning a value with type return_type taking n arguments </td><td>FAKE_VALUE_FUNC(int, DISPLAY_get_line_insert_index); </td></tr>
<tr>
<td>RESET_FAKE(fn); </td><td>Reset the state of fake function called fn </td><td>RESET_FAKE(DISPLAY_init); </td></tr>
</table>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
        <script type="text/javascript" src="../../doxy-boot.js"></script>
</html>

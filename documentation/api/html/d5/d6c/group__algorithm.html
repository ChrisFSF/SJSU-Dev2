<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.6"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>SJSU-Dev2: algorithm</title>
        <!--<link href="../../tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="../../dynsections.js"></script>
        <link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
        <link href="../../doxygen.css" rel="stylesheet" type="text/css" />
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
        <link href="../../jquery.smartmenus.bootstrap.css" rel="stylesheet">
        <script type="text/javascript" src="../../jquery.smartmenus.min.js"></script>
        <!-- SmartMenus jQuery Bootstrap Addon -->
        <script type="text/javascript" src="../../jquery.smartmenus.bootstrap.min.js"></script>
        <!-- SmartMenus jQuery plugin -->
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">SJSU-Dev2 </a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">algorithm</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3c6f2bcb1008f9074aa7a649611b1d1d"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TCompare &gt; </td></tr>
<tr class="memitem:ga3c6f2bcb1008f9074aa7a649611b1d1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/d71/structstd_1_1pair.html">std::pair</a>&lt; TIterator, TIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#ga3c6f2bcb1008f9074aa7a649611b1d1d">etl::minmax_element</a> (TIterator begin, TIterator end, TCompare compare)</td></tr>
<tr class="separator:ga3c6f2bcb1008f9074aa7a649611b1d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69c552b4f8c53673b6c5175e482f1a04"><td class="memTemplParams" colspan="2">template&lt;typename TIterator &gt; </td></tr>
<tr class="memitem:ga69c552b4f8c53673b6c5175e482f1a04"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/d71/structstd_1_1pair.html">std::pair</a>&lt; TIterator, TIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#ga69c552b4f8c53673b6c5175e482f1a04">etl::minmax_element</a> (TIterator begin, TIterator end)</td></tr>
<tr class="separator:ga69c552b4f8c53673b6c5175e482f1a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b669e14c867b03129ef8255cba50e64"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7b669e14c867b03129ef8255cba50e64"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/d71/structstd_1_1pair.html">std::pair</a>&lt; const T &amp;, const T &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#ga7b669e14c867b03129ef8255cba50e64">etl::minmax</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="separator:ga7b669e14c867b03129ef8255cba50e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e1a74f0d4b60492e3c726eb41fb5b28"><td class="memTemplParams" colspan="2">template&lt;typename T , typename TCompare &gt; </td></tr>
<tr class="memitem:ga0e1a74f0d4b60492e3c726eb41fb5b28"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/d71/structstd_1_1pair.html">std::pair</a>&lt; const T &amp;, const T &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#ga0e1a74f0d4b60492e3c726eb41fb5b28">etl::minmax</a> (const T &amp;a, const T &amp;b, TCompare compare)</td></tr>
<tr class="separator:ga0e1a74f0d4b60492e3c726eb41fb5b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga087c44b697b7bf0199f79c075b0df10f"><td class="memTemplParams" colspan="2">template&lt;typename TIterator &gt; </td></tr>
<tr class="memitem:ga087c44b697b7bf0199f79c075b0df10f"><td class="memTemplItemLeft" align="right" valign="top">TIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#ga087c44b697b7bf0199f79c075b0df10f">etl::is_sorted_until</a> (TIterator begin, TIterator end)</td></tr>
<tr class="separator:ga087c44b697b7bf0199f79c075b0df10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a23368d85895561099ec4fbfef90a43"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TCompare &gt; </td></tr>
<tr class="memitem:ga2a23368d85895561099ec4fbfef90a43"><td class="memTemplItemLeft" align="right" valign="top">TIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#ga2a23368d85895561099ec4fbfef90a43">etl::is_sorted_until</a> (TIterator begin, TIterator end, TCompare compare)</td></tr>
<tr class="separator:ga2a23368d85895561099ec4fbfef90a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf9646c7c7c670f1f83bcad509f90bf0"><td class="memTemplParams" colspan="2">template&lt;typename TIterator &gt; </td></tr>
<tr class="memitem:gacf9646c7c7c670f1f83bcad509f90bf0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#gacf9646c7c7c670f1f83bcad509f90bf0">etl::is_sorted</a> (TIterator begin, TIterator end)</td></tr>
<tr class="separator:gacf9646c7c7c670f1f83bcad509f90bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab418f05deb2a9d4db264a6d2a24c9da"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TCompare &gt; </td></tr>
<tr class="memitem:gaab418f05deb2a9d4db264a6d2a24c9da"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#gaab418f05deb2a9d4db264a6d2a24c9da">etl::is_sorted</a> (TIterator begin, TIterator end, TCompare compare)</td></tr>
<tr class="separator:gaab418f05deb2a9d4db264a6d2a24c9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe118fb4198e6cbba850936bdb472cd2"><td class="memTemplParams" colspan="2">template&lt;typename TInputIterator , typename TOutputIterator &gt; </td></tr>
<tr class="memitem:gafe118fb4198e6cbba850936bdb472cd2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/d11/structetl_1_1enable__if.html">etl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="../../d5/df3/structetl_1_1is__random__iterator.html">etl::is_random_iterator</a><br class="typebreak"/>
&lt; TInputIterator &gt;::value <br class="typebreak"/>
&amp;&amp;<a class="el" href="../../d5/df3/structetl_1_1is__random__iterator.html">etl::is_random_iterator</a><br class="typebreak"/>
&lt; TOutputIterator &gt;::value, <br class="typebreak"/>
TOutputIterator &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#gafe118fb4198e6cbba850936bdb472cd2">etl::copy</a> (TInputIterator i_begin, TInputIterator i_end, TOutputIterator o_begin, TOutputIterator o_end)</td></tr>
<tr class="separator:gafe118fb4198e6cbba850936bdb472cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3706bd7f9075add7c1cb975f0290f503"><td class="memTemplParams" colspan="2">template&lt;typename TInputIterator , typename TSize , typename TOutputIterator &gt; </td></tr>
<tr class="memitem:ga3706bd7f9075add7c1cb975f0290f503"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/d11/structetl_1_1enable__if.html">etl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="../../d5/df3/structetl_1_1is__random__iterator.html">etl::is_random_iterator</a><br class="typebreak"/>
&lt; TInputIterator &gt;::value, <br class="typebreak"/>
TOutputIterator &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#ga3706bd7f9075add7c1cb975f0290f503">etl::copy_n</a> (TInputIterator i_begin, TSize n, TOutputIterator o_begin)</td></tr>
<tr class="separator:ga3706bd7f9075add7c1cb975f0290f503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d8c7743a08d5c274670da5c6e32c465"><td class="memTemplParams" colspan="2">template&lt;typename TInputIterator , typename TSize , typename TOutputIterator &gt; </td></tr>
<tr class="memitem:ga6d8c7743a08d5c274670da5c6e32c465"><td class="memTemplItemLeft" align="right" valign="top">TOutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#ga6d8c7743a08d5c274670da5c6e32c465">etl::copy_n</a> (TInputIterator i_begin, TSize n, TOutputIterator o_begin, TOutputIterator o_end)</td></tr>
<tr class="separator:ga6d8c7743a08d5c274670da5c6e32c465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52a4727874943477611f5d1a48896aac"><td class="memTemplParams" colspan="2">template&lt;typename TInputIterator , typename TSize1 , typename TOutputIterator , typename TSize2 &gt; </td></tr>
<tr class="memitem:ga52a4727874943477611f5d1a48896aac"><td class="memTemplItemLeft" align="right" valign="top">TOutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#ga52a4727874943477611f5d1a48896aac">etl::copy_n</a> (TInputIterator i_begin, TSize1 n1, TOutputIterator o_begin, TSize2 n2)</td></tr>
<tr class="separator:ga52a4727874943477611f5d1a48896aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga715d29eff9f86bc298dc0bf188feb84f"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TOutputIterator , typename TUnaryPredicate &gt; </td></tr>
<tr class="memitem:ga715d29eff9f86bc298dc0bf188feb84f"><td class="memTemplItemLeft" align="right" valign="top">TOutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#ga715d29eff9f86bc298dc0bf188feb84f">etl::copy_if</a> (TIterator begin, TIterator end, TOutputIterator out, TUnaryPredicate predicate)</td></tr>
<tr class="separator:ga715d29eff9f86bc298dc0bf188feb84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7c565b3a0f90e00ba844918173270b7"><td class="memTemplParams" colspan="2">template&lt;typename TInputIterator , typename TOutputIterator , typename TUnaryPredicate &gt; </td></tr>
<tr class="memitem:gab7c565b3a0f90e00ba844918173270b7"><td class="memTemplItemLeft" align="right" valign="top">TOutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#gab7c565b3a0f90e00ba844918173270b7">etl::copy_if</a> (TInputIterator i_begin, TInputIterator i_end, TOutputIterator o_begin, TOutputIterator o_end, TUnaryPredicate predicate)</td></tr>
<tr class="separator:gab7c565b3a0f90e00ba844918173270b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09931fd412ffb43680f8762ce0eb99eb"><td class="memTemplParams" colspan="2">template&lt;typename TInputIterator , typename TSize , typename TOutputIterator , typename TUnaryPredicate &gt; </td></tr>
<tr class="memitem:ga09931fd412ffb43680f8762ce0eb99eb"><td class="memTemplItemLeft" align="right" valign="top">TOutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#ga09931fd412ffb43680f8762ce0eb99eb">etl::copy_n_if</a> (TInputIterator i_begin, TSize n, TOutputIterator o_begin, TUnaryPredicate predicate)</td></tr>
<tr class="separator:ga09931fd412ffb43680f8762ce0eb99eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47cda71a90079119d5a9a861a9805ff2"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TValue &gt; </td></tr>
<tr class="memitem:ga47cda71a90079119d5a9a861a9805ff2"><td class="memTemplItemLeft" align="right" valign="top">TIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#ga47cda71a90079119d5a9a861a9805ff2">etl::binary_find</a> (TIterator begin, TIterator end, const TValue &amp;value)</td></tr>
<tr class="separator:ga47cda71a90079119d5a9a861a9805ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d1ab79d93dbff5536a491406cc7a97f"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TValue , typename TBinaryPredicate , typename TBinaryEquality &gt; </td></tr>
<tr class="memitem:ga7d1ab79d93dbff5536a491406cc7a97f"><td class="memTemplItemLeft" align="right" valign="top">TIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#ga7d1ab79d93dbff5536a491406cc7a97f">etl::binary_find</a> (TIterator begin, TIterator end, const TValue &amp;value, TBinaryPredicate predicate, TBinaryEquality equality)</td></tr>
<tr class="separator:ga7d1ab79d93dbff5536a491406cc7a97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe8778b98aeab07dd8cb41a93469444c"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TUnaryPredicate &gt; </td></tr>
<tr class="memitem:gafe8778b98aeab07dd8cb41a93469444c"><td class="memTemplItemLeft" align="right" valign="top">TIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#gafe8778b98aeab07dd8cb41a93469444c">etl::find_if_not</a> (TIterator begin, TIterator end, TUnaryPredicate predicate)</td></tr>
<tr class="separator:gafe8778b98aeab07dd8cb41a93469444c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61f873a3f1ccac92f205ff7819bed12c"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TUnaryPredicate &gt; </td></tr>
<tr class="memitem:ga61f873a3f1ccac92f205ff7819bed12c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#ga61f873a3f1ccac92f205ff7819bed12c">etl::all_of</a> (TIterator begin, TIterator end, TUnaryPredicate predicate)</td></tr>
<tr class="separator:ga61f873a3f1ccac92f205ff7819bed12c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68ceb2c29a75891da37818cb16e50844"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TUnaryPredicate &gt; </td></tr>
<tr class="memitem:ga68ceb2c29a75891da37818cb16e50844"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#ga68ceb2c29a75891da37818cb16e50844">etl::any_of</a> (TIterator begin, TIterator end, TUnaryPredicate predicate)</td></tr>
<tr class="separator:ga68ceb2c29a75891da37818cb16e50844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f9d7f6841ac31509eba528eb05394aa"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TUnaryPredicate &gt; </td></tr>
<tr class="memitem:ga1f9d7f6841ac31509eba528eb05394aa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#ga1f9d7f6841ac31509eba528eb05394aa">etl::none_of</a> (TIterator begin, TIterator end, TUnaryPredicate predicate)</td></tr>
<tr class="separator:ga1f9d7f6841ac31509eba528eb05394aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51b070e3453360b3e9f86f08e8cd968e"><td class="memTemplParams" colspan="2">template&lt;typename TIterator1 , typename TIterator2 &gt; </td></tr>
<tr class="memitem:ga51b070e3453360b3e9f86f08e8cd968e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#ga51b070e3453360b3e9f86f08e8cd968e">etl::is_permutation</a> (TIterator1 begin1, TIterator1 end1, TIterator2 begin2)</td></tr>
<tr class="separator:ga51b070e3453360b3e9f86f08e8cd968e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefae9d4732ac3d23a5c8a98934f29a73"><td class="memTemplParams" colspan="2">template&lt;typename TIterator1 , typename TIterator2 &gt; </td></tr>
<tr class="memitem:gaefae9d4732ac3d23a5c8a98934f29a73"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#gaefae9d4732ac3d23a5c8a98934f29a73">etl::is_permutation</a> (TIterator1 begin1, TIterator1 end1, TIterator2 begin2, TIterator2 end2)</td></tr>
<tr class="separator:gaefae9d4732ac3d23a5c8a98934f29a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b9fd8300a5aa91770e62d38bc1b2f7f"><td class="memTemplParams" colspan="2">template&lt;typename TIterator1 , typename TIterator2 , typename TBinaryPredicate &gt; </td></tr>
<tr class="memitem:ga4b9fd8300a5aa91770e62d38bc1b2f7f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#ga4b9fd8300a5aa91770e62d38bc1b2f7f">etl::is_permutation</a> (TIterator1 begin1, TIterator1 end1, TIterator2 begin2, TBinaryPredicate predicate)</td></tr>
<tr class="separator:ga4b9fd8300a5aa91770e62d38bc1b2f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c4311834725db944b57f1bc6257b6d5"><td class="memTemplParams" colspan="2">template&lt;typename TIterator1 , typename TIterator2 , typename TBinaryPredicate &gt; </td></tr>
<tr class="memitem:ga7c4311834725db944b57f1bc6257b6d5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#ga7c4311834725db944b57f1bc6257b6d5">etl::is_permutation</a> (TIterator1 begin1, TIterator1 end1, TIterator2 begin2, TIterator2 end2, TBinaryPredicate predicate)</td></tr>
<tr class="separator:ga7c4311834725db944b57f1bc6257b6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga868f7df6a120febcfb4372c2f656c136"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TUnaryPredicate &gt; </td></tr>
<tr class="memitem:ga868f7df6a120febcfb4372c2f656c136"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#ga868f7df6a120febcfb4372c2f656c136">etl::is_partitioned</a> (TIterator begin, TIterator end, TUnaryPredicate predicate)</td></tr>
<tr class="separator:ga868f7df6a120febcfb4372c2f656c136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0be684913b7cf9b17ec1e8ea30cc2a03"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TUnaryPredicate &gt; </td></tr>
<tr class="memitem:ga0be684913b7cf9b17ec1e8ea30cc2a03"><td class="memTemplItemLeft" align="right" valign="top">TIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#ga0be684913b7cf9b17ec1e8ea30cc2a03">etl::partition_point</a> (TIterator begin, TIterator end, TUnaryPredicate predicate)</td></tr>
<tr class="separator:ga0be684913b7cf9b17ec1e8ea30cc2a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c6a9297b1b106897f3f438f69ee0538"><td class="memTemplParams" colspan="2">template&lt;typename TSource , typename TDestinationTrue , typename TDestinationFalse , typename TUnaryPredicate &gt; </td></tr>
<tr class="memitem:ga4c6a9297b1b106897f3f438f69ee0538"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/d71/structstd_1_1pair.html">std::pair</a>&lt; TDestinationTrue, <br class="typebreak"/>
TDestinationFalse &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#ga4c6a9297b1b106897f3f438f69ee0538">etl::partition_copy</a> (TSource begin, TSource end, TDestinationTrue destination_true, TDestinationFalse destination_false, TUnaryPredicate predicate)</td></tr>
<tr class="separator:ga4c6a9297b1b106897f3f438f69ee0538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga157238992977b7227d35dc197672d46f"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TUnaryFunction , typename TUnaryPredicate &gt; </td></tr>
<tr class="memitem:ga157238992977b7227d35dc197672d46f"><td class="memTemplItemLeft" align="right" valign="top">TUnaryFunction&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#ga157238992977b7227d35dc197672d46f">etl::for_each_if</a> (TIterator begin, const TIterator end, TUnaryFunction function, TUnaryPredicate predicate)</td></tr>
<tr class="separator:ga157238992977b7227d35dc197672d46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaef3105161f18db04055950b5ea4c00d"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TSize , typename TUnaryFunction &gt; </td></tr>
<tr class="memitem:gaaef3105161f18db04055950b5ea4c00d"><td class="memTemplItemLeft" align="right" valign="top">TIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#gaaef3105161f18db04055950b5ea4c00d">etl::for_each_n</a> (TIterator begin, TSize n, TUnaryFunction function)</td></tr>
<tr class="separator:gaaef3105161f18db04055950b5ea4c00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d65d5592b156a616974e580a21584eb"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TSize , typename TUnaryFunction , typename TUnaryPredicate &gt; </td></tr>
<tr class="memitem:ga8d65d5592b156a616974e580a21584eb"><td class="memTemplItemLeft" align="right" valign="top">TIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#ga8d65d5592b156a616974e580a21584eb">etl::for_each_n_if</a> (TIterator begin, TSize n, TUnaryFunction function, TUnaryPredicate predicate)</td></tr>
<tr class="separator:ga8d65d5592b156a616974e580a21584eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4eb65072e3ce642e24a7193315914f05"><td class="memTemplParams" colspan="2">template&lt;typename TInputIterator , typename TOutputIterator , typename TUnaryFunction &gt; </td></tr>
<tr class="memitem:ga4eb65072e3ce642e24a7193315914f05"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#ga4eb65072e3ce642e24a7193315914f05">etl::transform</a> (TInputIterator i_begin, TInputIterator i_end, TOutputIterator o_begin, TOutputIterator o_end, TUnaryFunction function)</td></tr>
<tr class="separator:ga4eb65072e3ce642e24a7193315914f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeec4e1155f60ffa6d94f002ad0d71400"><td class="memTemplParams" colspan="2">template&lt;typename TInputIterator , typename TSize , typename TOutputIterator , typename TUnaryFunction &gt; </td></tr>
<tr class="memitem:gaeec4e1155f60ffa6d94f002ad0d71400"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/d11/structetl_1_1enable__if.html">etl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="../../d5/df3/structetl_1_1is__random__iterator.html">etl::is_random_iterator</a><br class="typebreak"/>
&lt; TInputIterator &gt;::value, <br class="typebreak"/>
void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#gaeec4e1155f60ffa6d94f002ad0d71400">etl::transform_n</a> (TInputIterator i_begin, TSize n, TOutputIterator o_begin, TUnaryFunction function)</td></tr>
<tr class="separator:gaeec4e1155f60ffa6d94f002ad0d71400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1894f2b3cf8722ed3f68762d60489b35"><td class="memTemplParams" colspan="2">template&lt;typename TInputIterator1 , typename TInputIterator2 , typename TSize , typename TOutputIterator , typename TBinaryFunction &gt; </td></tr>
<tr class="memitem:ga1894f2b3cf8722ed3f68762d60489b35"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/d11/structetl_1_1enable__if.html">etl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="../../d5/df3/structetl_1_1is__random__iterator.html">etl::is_random_iterator</a><br class="typebreak"/>
&lt; TInputIterator1 &gt;::value <br class="typebreak"/>
&amp;&amp;<a class="el" href="../../d5/df3/structetl_1_1is__random__iterator.html">etl::is_random_iterator</a><br class="typebreak"/>
&lt; TInputIterator2 &gt;::value, <br class="typebreak"/>
void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#ga1894f2b3cf8722ed3f68762d60489b35">etl::transform_n</a> (TInputIterator1 i_begin1, TInputIterator2 i_begin2, TSize n, TOutputIterator o_begin, TBinaryFunction function)</td></tr>
<tr class="separator:ga1894f2b3cf8722ed3f68762d60489b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga152a7bb1e9822dc5b99786011f858442"><td class="memTemplParams" colspan="2">template&lt;typename TInputIterator , typename TOutputIterator , typename TUnaryFunction , typename TUnaryPredicate &gt; </td></tr>
<tr class="memitem:ga152a7bb1e9822dc5b99786011f858442"><td class="memTemplItemLeft" align="right" valign="top">TOutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#ga152a7bb1e9822dc5b99786011f858442">etl::transform_if</a> (TInputIterator i_begin, const TInputIterator i_end, TOutputIterator o_begin, TUnaryFunction function, TUnaryPredicate predicate)</td></tr>
<tr class="separator:ga152a7bb1e9822dc5b99786011f858442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5ee98aa1bc356a7b5788bd60eed5421"><td class="memTemplParams" colspan="2">template&lt;typename TInputIterator1 , typename TInputIterator2 , typename TOutputIterator , typename TBinaryFunction , typename TBinaryPredicate &gt; </td></tr>
<tr class="memitem:gae5ee98aa1bc356a7b5788bd60eed5421"><td class="memTemplItemLeft" align="right" valign="top">TOutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#gae5ee98aa1bc356a7b5788bd60eed5421">etl::transform_if</a> (TInputIterator1 i_begin1, const TInputIterator1 i_end1, TInputIterator2 i_begin2, TOutputIterator o_begin, TBinaryFunction function, TBinaryPredicate predicate)</td></tr>
<tr class="separator:gae5ee98aa1bc356a7b5788bd60eed5421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50b89670785401220a2d4f1984cccaf7"><td class="memTemplParams" colspan="2">template&lt;typename TInputIterator , typename TSize , typename TOutputIterator , typename TUnaryFunction , typename TUnaryPredicate &gt; </td></tr>
<tr class="memitem:ga50b89670785401220a2d4f1984cccaf7"><td class="memTemplItemLeft" align="right" valign="top">TOutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#ga50b89670785401220a2d4f1984cccaf7">etl::transform_n_if</a> (TInputIterator i_begin, TSize n, TOutputIterator o_begin, TUnaryFunction function, TUnaryPredicate predicate)</td></tr>
<tr class="separator:ga50b89670785401220a2d4f1984cccaf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad25af410cf011b9fe8babedb1272a82b"><td class="memTemplParams" colspan="2">template&lt;typename TInputIterator1 , typename TInputIterator2 , typename TSize , typename TOutputIterator , typename TBinaryFunction , typename TBinaryPredicate &gt; </td></tr>
<tr class="memitem:gad25af410cf011b9fe8babedb1272a82b"><td class="memTemplItemLeft" align="right" valign="top">TOutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#gad25af410cf011b9fe8babedb1272a82b">etl::transform_n_if</a> (TInputIterator1 i_begin1, TInputIterator2 i_begin2, TSize n, TOutputIterator o_begin, TBinaryFunction function, TBinaryPredicate predicate)</td></tr>
<tr class="separator:gad25af410cf011b9fe8babedb1272a82b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5d6d5db799c42d4e5fdeefce4cb2194"><td class="memTemplParams" colspan="2">template&lt;typename TSource , typename TDestinationTrue , typename TDestinationFalse , typename TUnaryFunctionTrue , typename TUnaryFunctionFalse , typename TUnaryPredicate &gt; </td></tr>
<tr class="memitem:gaa5d6d5db799c42d4e5fdeefce4cb2194"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/d71/structstd_1_1pair.html">std::pair</a>&lt; TDestinationTrue, <br class="typebreak"/>
TDestinationFalse &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#gaa5d6d5db799c42d4e5fdeefce4cb2194">etl::partition_transform</a> (TSource begin, TSource end, TDestinationTrue destination_true, TDestinationFalse destination_false, TUnaryFunctionTrue function_true, TUnaryFunctionFalse function_false, TUnaryPredicate predicate)</td></tr>
<tr class="separator:gaa5d6d5db799c42d4e5fdeefce4cb2194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19c23f81d6ac296db69eb99ff2b1b902"><td class="memTemplParams" colspan="2">template&lt;typename TSource1 , typename TSource2 , typename TDestinationTrue , typename TDestinationFalse , typename TBinaryFunctionTrue , typename TBinaryFunctionFalse , typename TBinaryPredicate &gt; </td></tr>
<tr class="memitem:ga19c23f81d6ac296db69eb99ff2b1b902"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/d71/structstd_1_1pair.html">std::pair</a>&lt; TDestinationTrue, <br class="typebreak"/>
TDestinationFalse &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#ga19c23f81d6ac296db69eb99ff2b1b902">etl::partition_transform</a> (TSource1 begin1, TSource1 end1, TSource2 begin2, TDestinationTrue destination_true, TDestinationFalse destination_false, TBinaryFunctionTrue function_true, TBinaryFunctionFalse function_false, TBinaryPredicate predicate)</td></tr>
<tr class="separator:ga19c23f81d6ac296db69eb99ff2b1b902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94008773e7989c80e8f65f1a52265c6c"><td class="memTemplParams" colspan="2">template&lt;typename TIterator , typename TCompare  = std::less&lt;typename std::iterator_traits&lt;TIterator&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:ga94008773e7989c80e8f65f1a52265c6c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d6c/group__algorithm.html#ga94008773e7989c80e8f65f1a52265c6c">etl::sort</a> (TIterator first, TIterator last, TCompare compare=TCompare())</td></tr>
<tr class="separator:ga94008773e7989c80e8f65f1a52265c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Reverse engineered algorithms from C++ 0x11 Additional new variants of certain algorithms. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga61f873a3f1ccac92f205ff7819bed12c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TUnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool etl::all_of </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>all_of</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/all_any_none_of"&gt; </p>

</div>
</div>
<a class="anchor" id="ga68ceb2c29a75891da37818cb16e50844"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TUnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool etl::any_of </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>any_of</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/all_any_none_of"&gt; </p>

</div>
</div>
<a class="anchor" id="ga47cda71a90079119d5a9a861a9805ff2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TIterator etl::binary_find </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TValue &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>binary_find</p>
<p>Does a binary search and returns an iterator to the value or end if not found. </p>

</div>
</div>
<a class="anchor" id="ga7d1ab79d93dbff5536a491406cc7a97f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TValue , typename TBinaryPredicate , typename TBinaryEquality &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TIterator etl::binary_find </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TValue &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TBinaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TBinaryEquality&#160;</td>
          <td class="paramname"><em>equality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>binary_find</p>
<p>Does a binary search and returns an iterator to the value or end if not found. </p>

</div>
</div>
<a class="anchor" id="gafe118fb4198e6cbba850936bdb472cd2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputIterator , typename TOutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d11/structetl_1_1enable__if.html">etl::enable_if</a>&lt;<a class="el" href="../../d5/df3/structetl_1_1is__random__iterator.html">etl::is_random_iterator</a>&lt;TInputIterator&gt;::value &amp;&amp; <a class="el" href="../../d5/df3/structetl_1_1is__random__iterator.html">etl::is_random_iterator</a>&lt;TOutputIterator&gt;::value, TOutputIterator&gt;::type etl::copy </td>
          <td>(</td>
          <td class="paramtype">TInputIterator&#160;</td>
          <td class="paramname"><em>i_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TInputIterator&#160;</td>
          <td class="paramname"><em>i_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>o_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>o_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>copy A form of copy where the smallest of the two ranges is used. There is currently no STL equivalent. Specialisation for random access iterators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_begin</td><td>Beginning of the input range. </td></tr>
    <tr><td class="paramname">i_end</td><td>End of the input range. </td></tr>
    <tr><td class="paramname">o_begin</td><td>Beginning of the output range. </td></tr>
    <tr><td class="paramname">o_end</td><td>End of the output range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga715d29eff9f86bc298dc0bf188feb84f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TOutputIterator , typename TUnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TOutputIterator etl::copy_if </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>copy_if</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/copy"&gt; </p>

</div>
</div>
<a class="anchor" id="gab7c565b3a0f90e00ba844918173270b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputIterator , typename TOutputIterator , typename TUnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TOutputIterator etl::copy_if </td>
          <td>(</td>
          <td class="paramtype">TInputIterator&#160;</td>
          <td class="paramname"><em>i_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TInputIterator&#160;</td>
          <td class="paramname"><em>i_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>o_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>o_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>copy_if A form of copy_if where it terminates when the first end iterator is reached. There is currently no STL equivelent. </p>

</div>
</div>
<a class="anchor" id="ga3706bd7f9075add7c1cb975f0290f503"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputIterator , typename TSize , typename TOutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d11/structetl_1_1enable__if.html">etl::enable_if</a>&lt;<a class="el" href="../../d5/df3/structetl_1_1is__random__iterator.html">etl::is_random_iterator</a>&lt;TInputIterator&gt;::value, TOutputIterator&gt;::type etl::copy_n </td>
          <td>(</td>
          <td class="paramtype">TInputIterator&#160;</td>
          <td class="paramname"><em>i_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSize&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>o_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>copy_n (Random input iterators)</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/copy_n"&gt; </p>

</div>
</div>
<a class="anchor" id="ga6d8c7743a08d5c274670da5c6e32c465"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputIterator , typename TSize , typename TOutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TOutputIterator etl::copy_n </td>
          <td>(</td>
          <td class="paramtype">TInputIterator&#160;</td>
          <td class="paramname"><em>i_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSize&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>o_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>o_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>copy_n A form of copy_n where the smallest of the two ranges is used. </p>

</div>
</div>
<a class="anchor" id="ga52a4727874943477611f5d1a48896aac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputIterator , typename TSize1 , typename TOutputIterator , typename TSize2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TOutputIterator etl::copy_n </td>
          <td>(</td>
          <td class="paramtype">TInputIterator&#160;</td>
          <td class="paramname"><em>i_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSize1&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>o_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSize2&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>copy_n A form of copy_n where the smallest of the two ranges is used. </p>

</div>
</div>
<a class="anchor" id="ga09931fd412ffb43680f8762ce0eb99eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputIterator , typename TSize , typename TOutputIterator , typename TUnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TOutputIterator etl::copy_n_if </td>
          <td>(</td>
          <td class="paramtype">TInputIterator&#160;</td>
          <td class="paramname"><em>i_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSize&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>o_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>copy_n_if Combination of copy_n and copy_if. </p>

</div>
</div>
<a class="anchor" id="gafe8778b98aeab07dd8cb41a93469444c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TUnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TIterator etl::find_if_not </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>find_if_not</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/find"&gt; </p>

</div>
</div>
<a class="anchor" id="ga157238992977b7227d35dc197672d46f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TUnaryFunction , typename TUnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TUnaryFunction etl::for_each_if </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryFunction&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like std::for_each but applies a predicate before calling the function. </p>

</div>
</div>
<a class="anchor" id="gaaef3105161f18db04055950b5ea4c00d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TSize , typename TUnaryFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TIterator etl::for_each_n </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSize&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryFunction&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like std::for_each but for 'n' iterations. </p>

</div>
</div>
<a class="anchor" id="ga8d65d5592b156a616974e580a21584eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TSize , typename TUnaryFunction , typename TUnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TIterator etl::for_each_n_if </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSize&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryFunction&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like std::for_each but applies a predicate before calling the function, for 'n' iterations </p>

</div>
</div>
<a class="anchor" id="ga868f7df6a120febcfb4372c2f656c136"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TUnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool etl::is_partitioned </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>is_partitioned</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/is_partitioned"&gt; </p>

</div>
</div>
<a class="anchor" id="ga51b070e3453360b3e9f86f08e8cd968e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator1 , typename TIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool etl::is_permutation </td>
          <td>(</td>
          <td class="paramtype">TIterator1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator2&#160;</td>
          <td class="paramname"><em>begin2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>is_permutation</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/is_permutation"&gt; </p>

</div>
</div>
<a class="anchor" id="gaefae9d4732ac3d23a5c8a98934f29a73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator1 , typename TIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool etl::is_permutation </td>
          <td>(</td>
          <td class="paramtype">TIterator1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator2&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator2&#160;</td>
          <td class="paramname"><em>end2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>is_permutation</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/is_permutation"&gt; </p>

</div>
</div>
<a class="anchor" id="ga4b9fd8300a5aa91770e62d38bc1b2f7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator1 , typename TIterator2 , typename TBinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool etl::is_permutation </td>
          <td>(</td>
          <td class="paramtype">TIterator1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator2&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TBinaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>is_permutation</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/is_permutation"&gt; </p>

</div>
</div>
<a class="anchor" id="ga7c4311834725db944b57f1bc6257b6d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator1 , typename TIterator2 , typename TBinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool etl::is_permutation </td>
          <td>(</td>
          <td class="paramtype">TIterator1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator2&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator2&#160;</td>
          <td class="paramname"><em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TBinaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>is_permutation</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/is_permutation"&gt; </p>

</div>
</div>
<a class="anchor" id="gacf9646c7c7c670f1f83bcad509f90bf0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool etl::is_sorted </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>is_sorted</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/is_sorted"&gt; </p>

</div>
</div>
<a class="anchor" id="gaab418f05deb2a9d4db264a6d2a24c9da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool etl::is_sorted </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TCompare&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>is_sorted</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/is_sorted"&gt; </p>

</div>
</div>
<a class="anchor" id="ga087c44b697b7bf0199f79c075b0df10f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TIterator etl::is_sorted_until </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>is_sorted_until</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/is_sorted_until"&gt; </p>

</div>
</div>
<a class="anchor" id="ga2a23368d85895561099ec4fbfef90a43"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TIterator etl::is_sorted_until </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TCompare&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>is_sorted_until</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/is_sorted_until"&gt; </p>

</div>
</div>
<a class="anchor" id="ga7b669e14c867b03129ef8255cba50e64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d71/structstd_1_1pair.html">std::pair</a>&lt;const T&amp;, const T&amp;&gt; etl::minmax </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>minmax</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/minmax"&gt; </p>

</div>
</div>
<a class="anchor" id="ga0e1a74f0d4b60492e3c726eb41fb5b28"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename TCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d71/structstd_1_1pair.html">std::pair</a>&lt;const T&amp;, const T&amp;&gt; etl::minmax </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TCompare&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>minmax</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/minmax"&gt; </p>

</div>
</div>
<a class="anchor" id="ga3c6f2bcb1008f9074aa7a649611b1d1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d71/structstd_1_1pair.html">std::pair</a>&lt;TIterator, TIterator&gt; etl::minmax_element </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TCompare&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the greatest and the smallest element in the range (begin, end).<br/>
 a href="http://en.cppreference.com/w/cpp/algorithm/minmax_element"&gt; </p>

</div>
</div>
<a class="anchor" id="ga69c552b4f8c53673b6c5175e482f1a04"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d71/structstd_1_1pair.html">std::pair</a>&lt;TIterator, TIterator&gt; etl::minmax_element </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>minmax_element</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/minmax_element"&gt; </p>

</div>
</div>
<a class="anchor" id="ga1f9d7f6841ac31509eba528eb05394aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TUnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool etl::none_of </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>none_of</p>
<p>a href="http://en.cppreference.com/w/cpp/algorithm/all_any_none_of"&gt; </p>

</div>
</div>
<a class="anchor" id="ga4c6a9297b1b106897f3f438f69ee0538"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSource , typename TDestinationTrue , typename TDestinationFalse , typename TUnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d71/structstd_1_1pair.html">std::pair</a>&lt;TDestinationTrue, TDestinationFalse&gt; etl::partition_copy </td>
          <td>(</td>
          <td class="paramtype">TSource&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSource&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TDestinationTrue&#160;</td>
          <td class="paramname"><em>destination_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TDestinationFalse&#160;</td>
          <td class="paramname"><em>destination_false</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the elements from the range (begin, end) to two different ranges depending on the value returned by the predicate.<br/>
 a href="http://en.cppreference.com/w/cpp/algorithm/partition_copy"&gt; </p>

</div>
</div>
<a class="anchor" id="ga0be684913b7cf9b17ec1e8ea30cc2a03"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TUnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TIterator etl::partition_point </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>partition_point a href="http://en.cppreference.com/w/cpp/algorithm/partition_point"&gt; </p>

</div>
</div>
<a class="anchor" id="gaa5d6d5db799c42d4e5fdeefce4cb2194"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSource , typename TDestinationTrue , typename TDestinationFalse , typename TUnaryFunctionTrue , typename TUnaryFunctionFalse , typename TUnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d71/structstd_1_1pair.html">std::pair</a>&lt;TDestinationTrue, TDestinationFalse&gt; etl::partition_transform </td>
          <td>(</td>
          <td class="paramtype">TSource&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSource&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TDestinationTrue&#160;</td>
          <td class="paramname"><em>destination_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TDestinationFalse&#160;</td>
          <td class="paramname"><em>destination_false</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryFunctionTrue&#160;</td>
          <td class="paramname"><em>function_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryFunctionFalse&#160;</td>
          <td class="paramname"><em>function_false</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transforms the elements from the range (begin, end) to two different ranges depending on the value returned by the predicate.<br/>
 </p>

</div>
</div>
<a class="anchor" id="ga19c23f81d6ac296db69eb99ff2b1b902"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSource1 , typename TSource2 , typename TDestinationTrue , typename TDestinationFalse , typename TBinaryFunctionTrue , typename TBinaryFunctionFalse , typename TBinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d71/structstd_1_1pair.html">std::pair</a>&lt;TDestinationTrue, TDestinationFalse&gt; etl::partition_transform </td>
          <td>(</td>
          <td class="paramtype">TSource1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSource1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSource2&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TDestinationTrue&#160;</td>
          <td class="paramname"><em>destination_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TDestinationFalse&#160;</td>
          <td class="paramname"><em>destination_false</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TBinaryFunctionTrue&#160;</td>
          <td class="paramname"><em>function_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TBinaryFunctionFalse&#160;</td>
          <td class="paramname"><em>function_false</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TBinaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transforms the elements from the ranges (begin1, end1) &amp; (begin2) to two different ranges depending on the value returned by the predicate. </p>

</div>
</div>
<a class="anchor" id="ga94008773e7989c80e8f65f1a52265c6c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TIterator , typename TCompare  = std::less&lt;typename std::iterator_traits&lt;TIterator&gt;::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void etl::sort </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TCompare&#160;</td>
          <td class="paramname"><em>compare</em> = <code>TCompare()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sorts the elements using shell sort. Uses users defined comparison. </p>

</div>
</div>
<a class="anchor" id="ga4eb65072e3ce642e24a7193315914f05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputIterator , typename TOutputIterator , typename TUnaryFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void etl::transform </td>
          <td>(</td>
          <td class="paramtype">TInputIterator&#160;</td>
          <td class="paramname"><em>i_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TInputIterator&#160;</td>
          <td class="paramname"><em>i_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>o_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>o_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryFunction&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A form of std::transform where the transform returns when the first range end is reached. There is currently no STL equivalent. </p>

</div>
</div>
<a class="anchor" id="ga152a7bb1e9822dc5b99786011f858442"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputIterator , typename TOutputIterator , typename TUnaryFunction , typename TUnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TOutputIterator etl::transform_if </td>
          <td>(</td>
          <td class="paramtype">TInputIterator&#160;</td>
          <td class="paramname"><em>i_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TInputIterator&#160;</td>
          <td class="paramname"><em>i_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>o_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryFunction&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like std::transform but applies a predicate before calling the function. </p>

</div>
</div>
<a class="anchor" id="gae5ee98aa1bc356a7b5788bd60eed5421"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputIterator1 , typename TInputIterator2 , typename TOutputIterator , typename TBinaryFunction , typename TBinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TOutputIterator etl::transform_if </td>
          <td>(</td>
          <td class="paramtype">TInputIterator1&#160;</td>
          <td class="paramname"><em>i_begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TInputIterator1&#160;</td>
          <td class="paramname"><em>i_end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TInputIterator2&#160;</td>
          <td class="paramname"><em>i_begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>o_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TBinaryFunction&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TBinaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like <a class="el" href="../../d5/d6c/group__algorithm.html#ga152a7bb1e9822dc5b99786011f858442">etl::transform_if</a> but inputs from two ranges. </p>

</div>
</div>
<a class="anchor" id="gaeec4e1155f60ffa6d94f002ad0d71400"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputIterator , typename TSize , typename TOutputIterator , typename TUnaryFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d11/structetl_1_1enable__if.html">etl::enable_if</a>&lt;<a class="el" href="../../d5/df3/structetl_1_1is__random__iterator.html">etl::is_random_iterator</a>&lt;TInputIterator&gt;::value, void&gt;::type etl::transform_n </td>
          <td>(</td>
          <td class="paramtype">TInputIterator&#160;</td>
          <td class="paramname"><em>i_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSize&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>o_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryFunction&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transform 'n' items. Random iterators. There is currently no STL equivalent. </p>

</div>
</div>
<a class="anchor" id="ga1894f2b3cf8722ed3f68762d60489b35"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputIterator1 , typename TInputIterator2 , typename TSize , typename TOutputIterator , typename TBinaryFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d11/structetl_1_1enable__if.html">etl::enable_if</a>&lt;<a class="el" href="../../d5/df3/structetl_1_1is__random__iterator.html">etl::is_random_iterator</a>&lt;TInputIterator1&gt;::value &amp;&amp; <a class="el" href="../../d5/df3/structetl_1_1is__random__iterator.html">etl::is_random_iterator</a>&lt;TInputIterator2&gt;::value, void&gt;::type etl::transform_n </td>
          <td>(</td>
          <td class="paramtype">TInputIterator1&#160;</td>
          <td class="paramname"><em>i_begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TInputIterator2&#160;</td>
          <td class="paramname"><em>i_begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSize&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>o_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TBinaryFunction&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transform 'n' items from two ranges. Random iterators. There is currently no STL equivalent. </p>

</div>
</div>
<a class="anchor" id="ga50b89670785401220a2d4f1984cccaf7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputIterator , typename TSize , typename TOutputIterator , typename TUnaryFunction , typename TUnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TOutputIterator etl::transform_n_if </td>
          <td>(</td>
          <td class="paramtype">TInputIterator&#160;</td>
          <td class="paramname"><em>i_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSize&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>o_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryFunction&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUnaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like std::transform_if, for 'n' items. </p>

</div>
</div>
<a class="anchor" id="gad25af410cf011b9fe8babedb1272a82b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInputIterator1 , typename TInputIterator2 , typename TSize , typename TOutputIterator , typename TBinaryFunction , typename TBinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TOutputIterator etl::transform_n_if </td>
          <td>(</td>
          <td class="paramtype">TInputIterator1&#160;</td>
          <td class="paramname"><em>i_begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TInputIterator2&#160;</td>
          <td class="paramname"><em>i_begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSize&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputIterator&#160;</td>
          <td class="paramname"><em>o_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TBinaryFunction&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TBinaryPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like <a class="el" href="../../d5/d6c/group__algorithm.html#ga152a7bb1e9822dc5b99786011f858442">etl::transform_if</a> but inputs from two ranges for 'n' items. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
        <script type="text/javascript" src="../../doxy-boot.js"></script>
</html>

<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.6"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>SJSU-Dev2: etl::iunordered_multiset&lt; TKey, THash, TKeyEqual &gt; Class Template Reference</title>
        <!--<link href="../../tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="../../dynsections.js"></script>
        <link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
        <link href="../../doxygen.css" rel="stylesheet" type="text/css" />
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
        <link href="../../jquery.smartmenus.bootstrap.css" rel="stylesheet">
        <script type="text/javascript" src="../../jquery.smartmenus.min.js"></script>
        <!-- SmartMenus jQuery Bootstrap Addon -->
        <script type="text/javascript" src="../../jquery.smartmenus.bootstrap.min.js"></script>
        <!-- SmartMenus jQuery plugin -->
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">SJSU-Dev2 </a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="../../classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="../../inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="../../functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d4/de2/namespaceetl.html">etl</a></li><li class="navelem"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">iunordered_multiset</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="../../db/da1/classetl_1_1iunordered__multiset-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">etl::iunordered_multiset&lt; TKey, THash, TKeyEqual &gt; Class Template Reference<div class="ingroups"><a class="el" href="../../db/dba/group__unordered__multiset.html">unordered_multiset</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="../../de/dcd/unordered__multiset_8h_source.html">unordered_multiset.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for etl::iunordered_multiset&lt; TKey, THash, TKeyEqual &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="../../dc/dfb/classetl_1_1iunordered__multiset__inherit__graph.png" border="0" usemap="#etl_1_1iunordered__multiset_3_01TKey_00_01THash_00_01TKeyEqual_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="etl_1_1iunordered__multiset_3_01TKey_00_01THash_00_01TKeyEqual_01_4_inherit__map" id="etl_1_1iunordered__multiset_3_01TKey_00_01THash_00_01TKeyEqual_01_4_inherit__map">
<area shape="rect" id="node2" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. " alt="" coords="5,97,200,138"/></map>
<center><span class="legend">[<a href="../../graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db5/classetl_1_1iunordered__multiset_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d58/classetl_1_1iunordered__multiset_1_1iterator.html">iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d32/structetl_1_1iunordered__multiset_1_1node__t.html">node_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abc746e7e98d6e344c234180c6a8b9d63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc746e7e98d6e344c234180c6a8b9d63"></a>
typedef TKey&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:abc746e7e98d6e344c234180c6a8b9d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5218aba858ac44b53bacfb9053b487"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb5218aba858ac44b53bacfb9053b487"></a>
typedef TKey&#160;</td><td class="memItemRight" valign="bottom"><b>key_type</b></td></tr>
<tr class="separator:aeb5218aba858ac44b53bacfb9053b487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad7d03a9b2e49195aa86927d3752ff9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ad7d03a9b2e49195aa86927d3752ff9"></a>
typedef THash&#160;</td><td class="memItemRight" valign="bottom"><b>hasher</b></td></tr>
<tr class="separator:a1ad7d03a9b2e49195aa86927d3752ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1fb6d08031048b225897454b075148"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc1fb6d08031048b225897454b075148"></a>
typedef TKeyEqual&#160;</td><td class="memItemRight" valign="bottom"><b>key_equal</b></td></tr>
<tr class="separator:abc1fb6d08031048b225897454b075148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e2429e0e956f23fc3c56dbfda931ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9e2429e0e956f23fc3c56dbfda931ac"></a>
typedef value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="separator:ac9e2429e0e956f23fc3c56dbfda931ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4411c48984e8b84df3c1cb63a9595d51"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4411c48984e8b84df3c1cb63a9595d51"></a>
typedef const value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="separator:a4411c48984e8b84df3c1cb63a9595d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d16621871ac7cd49f602224d1ed1f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67d16621871ac7cd49f602224d1ed1f3"></a>
typedef value_type *&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr class="separator:a67d16621871ac7cd49f602224d1ed1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae431cbf700cf6573dcf7669b70120f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ae431cbf700cf6573dcf7669b70120f"></a>
typedef const value_type *&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr class="separator:a4ae431cbf700cf6573dcf7669b70120f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab150cdd1b41ada2a45777dccb59ed3de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab150cdd1b41ada2a45777dccb59ed3de"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:ab150cdd1b41ada2a45777dccb59ed3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a06b17b9178e39da943579eef43a1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79a06b17b9178e39da943579eef43a1a"></a>
typedef <a class="el" href="../../d4/dd4/structetl_1_1parameter__type.html">etl::parameter_type</a><br class="typebreak"/>
&lt; TKey &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>key_parameter_t</b></td></tr>
<tr class="separator:a79a06b17b9178e39da943579eef43a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e7f6f77e540be7795d74e287206c6b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6e7f6f77e540be7795d74e287206c6b"></a>
typedef <a class="el" href="../../d0/d9f/structetl_1_1forward__link.html">etl::forward_link</a>&lt; 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>link_t</b></td></tr>
<tr class="separator:ad6e7f6f77e540be7795d74e287206c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2eb41e278fa5f325b6f42a6c7e12a8b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2eb41e278fa5f325b6f42a6c7e12a8b"></a>
typedef <a class="el" href="../../db/d68/classetl_1_1intrusive__forward__list_1_1iterator.html">bucket_t::iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>local_iterator</b></td></tr>
<tr class="separator:ad2eb41e278fa5f325b6f42a6c7e12a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee40f1ad58016ded45a11df1c16a7296"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee40f1ad58016ded45a11df1c16a7296"></a>
typedef <a class="el" href="../../d1/d99/classetl_1_1intrusive__forward__list_1_1const__iterator.html">bucket_t::const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>local_const_iterator</b></td></tr>
<tr class="separator:aee40f1ad58016ded45a11df1c16a7296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68c5ae860328c9d034ace7d4cc00cc6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac68c5ae860328c9d034ace7d4cc00cc6"></a>
typedef <a class="el" href="../../db/dcf/structstd_1_1iterator__traits.html">std::iterator_traits</a><br class="typebreak"/>
&lt; <a class="el" href="../../dc/d58/classetl_1_1iunordered__multiset_1_1iterator.html">iterator</a> &gt;::difference_type&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:ac68c5ae860328c9d034ace7d4cc00cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aae01556543a1f003f82f0439e92b10c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d58/classetl_1_1iunordered__multiset_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#aae01556543a1f003f82f0439e92b10c1">begin</a> ()</td></tr>
<tr class="separator:aae01556543a1f003f82f0439e92b10c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a52d4f4a5c44c2f7ba163da8527bb50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/db5/classetl_1_1iunordered__multiset_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a6a52d4f4a5c44c2f7ba163da8527bb50">begin</a> () const </td></tr>
<tr class="separator:a6a52d4f4a5c44c2f7ba163da8527bb50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc963be05415a8a0fc875790268f964"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/db5/classetl_1_1iunordered__multiset_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a6cc963be05415a8a0fc875790268f964">cbegin</a> () const </td></tr>
<tr class="separator:a6cc963be05415a8a0fc875790268f964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f08683ed4b5e9c589835fa269625780"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/d68/classetl_1_1intrusive__forward__list_1_1iterator.html">local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a5f08683ed4b5e9c589835fa269625780">begin</a> (size_t i)</td></tr>
<tr class="separator:a5f08683ed4b5e9c589835fa269625780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad113087f66f773436d8cea26f477816b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d99/classetl_1_1intrusive__forward__list_1_1const__iterator.html">local_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#ad113087f66f773436d8cea26f477816b">begin</a> (size_t i) const </td></tr>
<tr class="separator:ad113087f66f773436d8cea26f477816b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8d351d59497ed29212990e94925a38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d99/classetl_1_1intrusive__forward__list_1_1const__iterator.html">local_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a6f8d351d59497ed29212990e94925a38">cbegin</a> (size_t i) const </td></tr>
<tr class="separator:a6f8d351d59497ed29212990e94925a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8d0a0c41f01f4c3e8cf3232985673a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d58/classetl_1_1iunordered__multiset_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a3b8d0a0c41f01f4c3e8cf3232985673a">end</a> ()</td></tr>
<tr class="separator:a3b8d0a0c41f01f4c3e8cf3232985673a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efa026467c1d67ea18256b04cdb9068"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/db5/classetl_1_1iunordered__multiset_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a8efa026467c1d67ea18256b04cdb9068">end</a> () const </td></tr>
<tr class="separator:a8efa026467c1d67ea18256b04cdb9068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d4ef1a591cb8fc3388c4f0bf1dbe24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/db5/classetl_1_1iunordered__multiset_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a10d4ef1a591cb8fc3388c4f0bf1dbe24">cend</a> () const </td></tr>
<tr class="separator:a10d4ef1a591cb8fc3388c4f0bf1dbe24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9757c5e1cda68da39f712368334ee34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/d68/classetl_1_1intrusive__forward__list_1_1iterator.html">local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#ac9757c5e1cda68da39f712368334ee34">end</a> (size_t i)</td></tr>
<tr class="separator:ac9757c5e1cda68da39f712368334ee34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6a84baebece3a5bc127f5c46608f46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d99/classetl_1_1intrusive__forward__list_1_1const__iterator.html">local_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a7d6a84baebece3a5bc127f5c46608f46">end</a> (size_t i) const </td></tr>
<tr class="separator:a7d6a84baebece3a5bc127f5c46608f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85315b7174d6e71849dea383671c6112"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d99/classetl_1_1intrusive__forward__list_1_1const__iterator.html">local_const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a85315b7174d6e71849dea383671c6112">cend</a> (size_t i) const </td></tr>
<tr class="separator:a85315b7174d6e71849dea383671c6112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f9e038125ba64b86bbec3535d31f5b"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#ac0f9e038125ba64b86bbec3535d31f5b">get_bucket_index</a> (key_parameter_t key) const </td></tr>
<tr class="separator:ac0f9e038125ba64b86bbec3535d31f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4365945515a1e44cf62caa67262bf2"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a3c4365945515a1e44cf62caa67262bf2">bucket_size</a> (key_parameter_t key) const </td></tr>
<tr class="separator:a3c4365945515a1e44cf62caa67262bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7796951d2600c9e348a9611b86a0ee9"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#ab7796951d2600c9e348a9611b86a0ee9">max_bucket_count</a> () const </td></tr>
<tr class="separator:ab7796951d2600c9e348a9611b86a0ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43acac193740051d7110cb3d5e0aa8f"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#ab43acac193740051d7110cb3d5e0aa8f">bucket_count</a> () const </td></tr>
<tr class="separator:ab43acac193740051d7110cb3d5e0aa8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c1777b3b94c358236e7e04a39abf2f"><td class="memTemplParams" colspan="2">template&lt;typename TIterator &gt; </td></tr>
<tr class="memitem:a61c1777b3b94c358236e7e04a39abf2f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a61c1777b3b94c358236e7e04a39abf2f">assign</a> (TIterator first_, TIterator last_)</td></tr>
<tr class="separator:a61c1777b3b94c358236e7e04a39abf2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4096dfb43a2ee13cce40b4912257c6fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/d71/structstd_1_1pair.html">std::pair</a>&lt; <a class="el" href="../../dc/d58/classetl_1_1iunordered__multiset_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a4096dfb43a2ee13cce40b4912257c6fa">insert</a> (const value_type &amp;key)</td></tr>
<tr class="separator:a4096dfb43a2ee13cce40b4912257c6fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcafd38dbdeea4b99aa7bfaef84c3532"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d58/classetl_1_1iunordered__multiset_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#afcafd38dbdeea4b99aa7bfaef84c3532">insert</a> (<a class="el" href="../../d4/db5/classetl_1_1iunordered__multiset_1_1const__iterator.html">const_iterator</a> position, const value_type &amp;key)</td></tr>
<tr class="separator:afcafd38dbdeea4b99aa7bfaef84c3532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b63de22e0dc58d1f442405fbbc4f56e"><td class="memTemplParams" colspan="2">template&lt;class TIterator &gt; </td></tr>
<tr class="memitem:a7b63de22e0dc58d1f442405fbbc4f56e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a7b63de22e0dc58d1f442405fbbc4f56e">insert</a> (TIterator first_, TIterator last_)</td></tr>
<tr class="separator:a7b63de22e0dc58d1f442405fbbc4f56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331b96b67b5ea4e1809bba0916848e67"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a331b96b67b5ea4e1809bba0916848e67">erase</a> (key_parameter_t key)</td></tr>
<tr class="separator:a331b96b67b5ea4e1809bba0916848e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3be01b721ae8487fdb1174b5458c20a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d58/classetl_1_1iunordered__multiset_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#ab3be01b721ae8487fdb1174b5458c20a">erase</a> (<a class="el" href="../../d4/db5/classetl_1_1iunordered__multiset_1_1const__iterator.html">const_iterator</a> ielement)</td></tr>
<tr class="separator:ab3be01b721ae8487fdb1174b5458c20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92504ab3bd354bc1643289b9716638d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d58/classetl_1_1iunordered__multiset_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a92504ab3bd354bc1643289b9716638d3">erase</a> (<a class="el" href="../../d4/db5/classetl_1_1iunordered__multiset_1_1const__iterator.html">const_iterator</a> first_, <a class="el" href="../../d4/db5/classetl_1_1iunordered__multiset_1_1const__iterator.html">const_iterator</a> last_)</td></tr>
<tr class="separator:a92504ab3bd354bc1643289b9716638d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8097efee0bce110362757fa22b7ea22c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8097efee0bce110362757fa22b7ea22c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a8097efee0bce110362757fa22b7ea22c">clear</a> ()</td></tr>
<tr class="memdesc:a8097efee0bce110362757fa22b7ea22c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. <br/></td></tr>
<tr class="separator:a8097efee0bce110362757fa22b7ea22c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d944059610f266eec4d9fccec96678"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a17d944059610f266eec4d9fccec96678">count</a> (key_parameter_t key) const </td></tr>
<tr class="separator:a17d944059610f266eec4d9fccec96678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e59844d174e1a9eed6af9c008b9e483"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d58/classetl_1_1iunordered__multiset_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a9e59844d174e1a9eed6af9c008b9e483">find</a> (key_parameter_t key)</td></tr>
<tr class="separator:a9e59844d174e1a9eed6af9c008b9e483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19700351018004c72c5c3d719269a791"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/db5/classetl_1_1iunordered__multiset_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a19700351018004c72c5c3d719269a791">find</a> (key_parameter_t key) const </td></tr>
<tr class="separator:a19700351018004c72c5c3d719269a791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812b37ad93ec70e5789ea1f45daf6cde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/d71/structstd_1_1pair.html">std::pair</a>&lt; <a class="el" href="../../dc/d58/classetl_1_1iunordered__multiset_1_1iterator.html">iterator</a>, <a class="el" href="../../dc/d58/classetl_1_1iunordered__multiset_1_1iterator.html">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a812b37ad93ec70e5789ea1f45daf6cde">equal_range</a> (key_parameter_t key)</td></tr>
<tr class="separator:a812b37ad93ec70e5789ea1f45daf6cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e3dbd451f813bf77afc6f751f05b61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/d71/structstd_1_1pair.html">std::pair</a>&lt; <a class="el" href="../../d4/db5/classetl_1_1iunordered__multiset_1_1const__iterator.html">const_iterator</a>, <br class="typebreak"/>
<a class="el" href="../../d4/db5/classetl_1_1iunordered__multiset_1_1const__iterator.html">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a24e3dbd451f813bf77afc6f751f05b61">equal_range</a> (key_parameter_t key) const </td></tr>
<tr class="separator:a24e3dbd451f813bf77afc6f751f05b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db656361fe20cf6a2dbcd16b2ee3eaf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9db656361fe20cf6a2dbcd16b2ee3eaf"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a9db656361fe20cf6a2dbcd16b2ee3eaf">size</a> () const </td></tr>
<tr class="memdesc:a9db656361fe20cf6a2dbcd16b2ee3eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. <br/></td></tr>
<tr class="separator:a9db656361fe20cf6a2dbcd16b2ee3eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec2d51db6fb412297ed2a648b24905f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ec2d51db6fb412297ed2a648b24905f"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a5ec2d51db6fb412297ed2a648b24905f">max_size</a> () const </td></tr>
<tr class="memdesc:a5ec2d51db6fb412297ed2a648b24905f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum possible size of the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. <br/></td></tr>
<tr class="separator:a5ec2d51db6fb412297ed2a648b24905f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1223355df2ffbe801c515e163821742f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1223355df2ffbe801c515e163821742f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a1223355df2ffbe801c515e163821742f">empty</a> () const </td></tr>
<tr class="memdesc:a1223355df2ffbe801c515e163821742f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> is empty. <br/></td></tr>
<tr class="separator:a1223355df2ffbe801c515e163821742f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079da0b0b424cb815fd3c7b860b90a8b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a079da0b0b424cb815fd3c7b860b90a8b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a079da0b0b424cb815fd3c7b860b90a8b">full</a> () const </td></tr>
<tr class="memdesc:a079da0b0b424cb815fd3c7b860b90a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> is full. <br/></td></tr>
<tr class="separator:a079da0b0b424cb815fd3c7b860b90a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f189838a7c57d5a3f6443c52c8e49ba"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a4f189838a7c57d5a3f6443c52c8e49ba">available</a> () const </td></tr>
<tr class="separator:a4f189838a7c57d5a3f6443c52c8e49ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a6de5a4724640fb1f3abe48deab59b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a03a6de5a4724640fb1f3abe48deab59b">load_factor</a> () const </td></tr>
<tr class="separator:a03a6de5a4724640fb1f3abe48deab59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9175ad0c8ed513aa29a8051ca7a35c9d"><td class="memItemLeft" align="right" valign="top">hasher&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a9175ad0c8ed513aa29a8051ca7a35c9d">hash_function</a> () const </td></tr>
<tr class="separator:a9175ad0c8ed513aa29a8051ca7a35c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89eff085176e5ee3a5a01299dcf56ec"><td class="memItemLeft" align="right" valign="top">key_equal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#aa89eff085176e5ee3a5a01299dcf56ec">key_eq</a> () const </td></tr>
<tr class="separator:aa89eff085176e5ee3a5a01299dcf56ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee48d995aceaf6a10aa1813b3134e48"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ee48d995aceaf6a10aa1813b3134e48"></a>
<a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">iunordered_multiset</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a9ee48d995aceaf6a10aa1813b3134e48">operator=</a> (const <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">iunordered_multiset</a> &amp;rhs)</td></tr>
<tr class="memdesc:a9ee48d995aceaf6a10aa1813b3134e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br/></td></tr>
<tr class="separator:a9ee48d995aceaf6a10aa1813b3134e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a01269ea4ceec927ef193db691e0574f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01269ea4ceec927ef193db691e0574f3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a01269ea4ceec927ef193db691e0574f3">iunordered_multiset</a> (<a class="el" href="../../d5/d0d/classetl_1_1ipool.html">pool_t</a> &amp;node_pool_, <a class="el" href="../../de/dd6/classetl_1_1intrusive__forward__list.html">bucket_t</a> *pbuckets_, size_t number_of_buckets_)</td></tr>
<tr class="memdesc:a01269ea4ceec927ef193db691e0574f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br/></td></tr>
<tr class="separator:a01269ea4ceec927ef193db691e0574f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b71336813276ecff6b35cd9f0ae7c98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b71336813276ecff6b35cd9f0ae7c98"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a3b71336813276ecff6b35cd9f0ae7c98">initialise</a> ()</td></tr>
<tr class="memdesc:a3b71336813276ecff6b35cd9f0ae7c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. <br/></td></tr>
<tr class="separator:a3b71336813276ecff6b35cd9f0ae7c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0383417190b92d787b91c9623a3116b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a0383417190b92d787b91c9623a3116b0">~iunordered_multiset</a> ()</td></tr>
<tr class="memdesc:a0383417190b92d787b91c9623a3116b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">For library debugging purposes only.  <a href="#a0383417190b92d787b91c9623a3116b0">More...</a><br/></td></tr>
<tr class="separator:a0383417190b92d787b91c9623a3116b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt;<br/>
class etl::iunordered_multiset&lt; TKey, THash, TKeyEqual &gt;</h3>

<p>The base class for specifically sized <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. Can be used as a reference type for all <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> containing a specific type. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0383417190b92d787b91c9623a3116b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::~<a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">iunordered_multiset</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For library debugging purposes only. </p>
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a61c1777b3b94c358236e7e04a39abf2f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename TIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>first_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>last_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assigns values to the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. If asserts or exceptions are enabled, emits <a class="el" href="../../de/d94/classetl_1_1unordered__multiset__full.html">unordered_multiset_full</a> if the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> does not have enough free space. If asserts or exceptions are enabled, emits <a class="el" href="../../d6/dc8/classetl_1_1unordered__multiset__iterator.html">unordered_multiset_iterator</a> if the iterators are reversed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The iterator to the first element. </td></tr>
    <tr><td class="paramname">last</td><td>The iterator to the last element + 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f189838a7c57d5a3f6443c52c8e49ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the remaining capacity. </p>
<dl class="section return"><dt>Returns</dt><dd>The remaining capacity. </dd></dl>

</div>
</div>
<a class="anchor" id="aae01556543a1f003f82f0439e92b10c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d58/classetl_1_1iunordered__multiset_1_1iterator.html">iterator</a> <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator to the beginning of the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the beginning of the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a52d4f4a5c44c2f7ba163da8527bb50"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db5/classetl_1_1iunordered__multiset_1_1const__iterator.html">const_iterator</a> <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="../../d4/db5/classetl_1_1iunordered__multiset_1_1const__iterator.html">const_iterator</a> to the beginning of the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A const iterator to the beginning of the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a5f08683ed4b5e9c589835fa269625780"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d68/classetl_1_1intrusive__forward__list_1_1iterator.html">local_iterator</a> <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator to the beginning of the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> bucket. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the beginning of the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> bucket. </dd></dl>

</div>
</div>
<a class="anchor" id="ad113087f66f773436d8cea26f477816b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d99/classetl_1_1intrusive__forward__list_1_1const__iterator.html">local_const_iterator</a> <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="../../d4/db5/classetl_1_1iunordered__multiset_1_1const__iterator.html">const_iterator</a> to the beginning of the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> bucket. </p>
<dl class="section return"><dt>Returns</dt><dd>A const iterator to the beginning of the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> bucket. </dd></dl>

</div>
</div>
<a class="anchor" id="ab43acac193740051d7110cb3d5e0aa8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of the buckets the container holds. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of the buckets the container holds. </dd></dl>

</div>
</div>
<a class="anchor" id="a3c4365945515a1e44cf62caa67262bf2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::bucket_size </td>
          <td>(</td>
          <td class="paramtype">key_parameter_t&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the size of the bucket key. </p>
<dl class="section return"><dt>Returns</dt><dd>The bucket size of the bucket key. </dd></dl>

</div>
</div>
<a class="anchor" id="a6cc963be05415a8a0fc875790268f964"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db5/classetl_1_1iunordered__multiset_1_1const__iterator.html">const_iterator</a> <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="../../d4/db5/classetl_1_1iunordered__multiset_1_1const__iterator.html">const_iterator</a> to the beginning of the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A const iterator to the beginning of the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f8d351d59497ed29212990e94925a38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d99/classetl_1_1intrusive__forward__list_1_1const__iterator.html">local_const_iterator</a> <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="../../d4/db5/classetl_1_1iunordered__multiset_1_1const__iterator.html">const_iterator</a> to the beginning of the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> bucket. </p>
<dl class="section return"><dt>Returns</dt><dd>A const iterator to the beginning of the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> bucket. </dd></dl>

</div>
</div>
<a class="anchor" id="a10d4ef1a591cb8fc3388c4f0bf1dbe24"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db5/classetl_1_1iunordered__multiset_1_1const__iterator.html">const_iterator</a> <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="../../d4/db5/classetl_1_1iunordered__multiset_1_1const__iterator.html">const_iterator</a> to the end of the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A const iterator to the end of the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a85315b7174d6e71849dea383671c6112"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d99/classetl_1_1intrusive__forward__list_1_1const__iterator.html">local_const_iterator</a> <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::cend </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="../../d4/db5/classetl_1_1iunordered__multiset_1_1const__iterator.html">const_iterator</a> to the end of the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> bucket. </p>
<dl class="section return"><dt>Returns</dt><dd>A const iterator to the end of the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> bucket. </dd></dl>

</div>
</div>
<a class="anchor" id="a17d944059610f266eec4d9fccec96678"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::count </td>
          <td>(</td>
          <td class="paramtype">key_parameter_t&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Counts an element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the key exists, otherwise 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b8d0a0c41f01f4c3e8cf3232985673a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d58/classetl_1_1iunordered__multiset_1_1iterator.html">iterator</a> <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator to the end of the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the end of the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a8efa026467c1d67ea18256b04cdb9068"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db5/classetl_1_1iunordered__multiset_1_1const__iterator.html">const_iterator</a> <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="../../d4/db5/classetl_1_1iunordered__multiset_1_1const__iterator.html">const_iterator</a> to the end of the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A const iterator to the end of the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ac9757c5e1cda68da39f712368334ee34"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d68/classetl_1_1intrusive__forward__list_1_1iterator.html">local_iterator</a> <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::end </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator to the end of the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> bucket. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the end of the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> bucket. </dd></dl>

</div>
</div>
<a class="anchor" id="a7d6a84baebece3a5bc127f5c46608f46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d99/classetl_1_1intrusive__forward__list_1_1const__iterator.html">local_const_iterator</a> <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::end </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="../../d4/db5/classetl_1_1iunordered__multiset_1_1const__iterator.html">const_iterator</a> to the end of the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> bucket. </p>
<dl class="section return"><dt>Returns</dt><dd>A const iterator to the end of the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> bucket. </dd></dl>

</div>
</div>
<a class="anchor" id="a812b37ad93ec70e5789ea1f45daf6cde"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d71/structstd_1_1pair.html">std::pair</a>&lt;<a class="el" href="../../dc/d58/classetl_1_1iunordered__multiset_1_1iterator.html">iterator</a>, <a class="el" href="../../dc/d58/classetl_1_1iunordered__multiset_1_1iterator.html">iterator</a>&gt; <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">key_parameter_t&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a range containing all elements with key key in the container. The range is defined by two iterators, the first pointing to the first element of the wanted range and the second pointing past the last element of the range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pair to the range of elements if the key exists, otherwise <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a3b8d0a0c41f01f4c3e8cf3232985673a">end()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a24e3dbd451f813bf77afc6f751f05b61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d71/structstd_1_1pair.html">std::pair</a>&lt;<a class="el" href="../../d4/db5/classetl_1_1iunordered__multiset_1_1const__iterator.html">const_iterator</a>, <a class="el" href="../../d4/db5/classetl_1_1iunordered__multiset_1_1const__iterator.html">const_iterator</a>&gt; <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">key_parameter_t&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a range containing all elements with key key in the container. The range is defined by two iterators, the first pointing to the first element of the wanted range and the second pointing past the last element of the range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const iterator pair to the range of elements if the key exists, otherwise <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a3b8d0a0c41f01f4c3e8cf3232985673a">end()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a331b96b67b5ea4e1809bba0916848e67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">key_parameter_t&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Erases an element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to erase. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements erased. </dd></dl>

</div>
</div>
<a class="anchor" id="ab3be01b721ae8487fdb1174b5458c20a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d58/classetl_1_1iunordered__multiset_1_1iterator.html">iterator</a> <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/db5/classetl_1_1iunordered__multiset_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>ielement</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Erases an element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ielement</td><td>Iterator to the element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a92504ab3bd354bc1643289b9716638d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d58/classetl_1_1iunordered__multiset_1_1iterator.html">iterator</a> <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/db5/classetl_1_1iunordered__multiset_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/db5/classetl_1_1iunordered__multiset_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Erases a range of elements. The range includes all the elements between first and last, including the element pointed by first, but not the one pointed to by last. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the last element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9e59844d174e1a9eed6af9c008b9e483"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d58/classetl_1_1iunordered__multiset_1_1iterator.html">iterator</a> <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::find </td>
          <td>(</td>
          <td class="paramtype">key_parameter_t&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds an element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the element if the key exists, otherwise <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a3b8d0a0c41f01f4c3e8cf3232985673a">end()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a19700351018004c72c5c3d719269a791"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db5/classetl_1_1iunordered__multiset_1_1const__iterator.html">const_iterator</a> <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::find </td>
          <td>(</td>
          <td class="paramtype">key_parameter_t&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds an element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the element if the key exists, otherwise <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html#a3b8d0a0c41f01f4c3e8cf3232985673a">end()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0f9e038125ba64b86bbec3535d31f5b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::get_bucket_index </td>
          <td>(</td>
          <td class="paramtype">key_parameter_t&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the bucket index for the key. </p>
<dl class="section return"><dt>Returns</dt><dd>The bucket index for the key. </dd></dl>

</div>
</div>
<a class="anchor" id="a9175ad0c8ed513aa29a8051ca7a35c9d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hasher <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::hash_function </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the function that hashes the keys. </p>
<dl class="section return"><dt>Returns</dt><dd>The function that hashes the keys.. </dd></dl>

</div>
</div>
<a class="anchor" id="a4096dfb43a2ee13cce40b4912257c6fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d71/structstd_1_1pair.html">std::pair</a>&lt;<a class="el" href="../../dc/d58/classetl_1_1iunordered__multiset_1_1iterator.html">iterator</a>, bool&gt; <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts a value to the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. If asserts or exceptions are enabled, emits <a class="el" href="../../de/d94/classetl_1_1unordered__multiset__full.html">unordered_multiset_full</a> if the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> is already full. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afcafd38dbdeea4b99aa7bfaef84c3532"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d58/classetl_1_1iunordered__multiset_1_1iterator.html">iterator</a> <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/db5/classetl_1_1iunordered__multiset_1_1const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts a value to the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. If asserts or exceptions are enabled, emits <a class="el" href="../../de/d94/classetl_1_1unordered__multiset__full.html">unordered_multiset_full</a> if the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> is already full. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The position to insert at. </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b63de22e0dc58d1f442405fbbc4f56e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<div class="memtemplate">
template&lt;class TIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>first_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIterator&#160;</td>
          <td class="paramname"><em>last_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts a range of values to the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a>. If asserts or exceptions are enabled, emits <a class="el" href="../../de/d94/classetl_1_1unordered__multiset__full.html">unordered_multiset_full</a> if the <a class="el" href="../../d8/de6/classetl_1_1unordered__multiset.html" title="A templated unordered_multiset implementation that uses a fixed size buffer. ">unordered_multiset</a> does not have enough free space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The position to insert at. </td></tr>
    <tr><td class="paramname">first</td><td>The first element to add. </td></tr>
    <tr><td class="paramname">last</td><td>The last + 1 element to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa89eff085176e5ee3a5a01299dcf56ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">key_equal <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::key_eq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the function that compares the keys. </p>
<dl class="section return"><dt>Returns</dt><dd>The function that compares the keys.. </dd></dl>

</div>
</div>
<a class="anchor" id="a03a6de5a4724640fb1f3abe48deab59b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the load factor = size / bucket_count. </p>
<dl class="section return"><dt>Returns</dt><dd>The load factor = size / bucket_count. </dd></dl>

</div>
</div>
<a class="anchor" id="ab7796951d2600c9e348a9611b86a0ee9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKey, typename THash = etl::hash&lt;TKey&gt;, typename TKeyEqual = std::equal_to&lt;TKey&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="../../d2/d5e/classetl_1_1iunordered__multiset.html">etl::iunordered_multiset</a>&lt; TKey, THash, TKeyEqual &gt;::max_bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the maximum number of the buckets the container can hold. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of the buckets the container can hold. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/travis/build/kammce/SJSU-Dev2/firmware/library/third_party/etl/<a class="el" href="../../de/dcd/unordered__multiset_8h_source.html">unordered_multiset.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
        <script type="text/javascript" src="../../doxy-boot.js"></script>
</html>
